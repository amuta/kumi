#!/usr/bin/env ruby
# frozen_string_literal: true

require "bundler/setup"
require "optparse"
require_relative "../lib/kumi"

cmd = ARGV.shift or abort "usage: kumi <parse|analyze|pp|golden|diff|profile|codegen|pack> ..."

case cmd
when "parse"
  path = ARGV.shift or abort "kumi parse <schema.kumi> [options]"
  opts = {}
  OptionParser.new do |o|
    o.on("--write", "Write golden file instead of diffing") { opts[:write] = true }
    o.on("--update", "Update golden file only if different") { opts[:update] = true }
    o.on("--json", "Use JSON format instead of text") { opts[:json] = true }
    o.on("--no-diff", "Just print output, don't diff") { opts[:no_diff] = true }
    o.on("--trace", "Enable state tracing") { opts[:trace] = true }
    o.on("--snap PHASES", "Snapshot phases") { |v| opts[:snap] = v }
    o.on("--snap-dir DIR", "Snapshot directory") { |v| opts[:snap_dir] = v }
  end.parse!(ARGV)

  success = Kumi::Dev::Parse.run(path, opts)
  exit(success ? 0 : 1)

when "analyze"
  path = ARGV.shift or abort "kumi analyze <schema-path>"
  opts = {}
  dump_key = nil
  side_tables = false
  OptionParser.new do |o|
    o.on("--trace") { opts[:trace] = true }
    o.on("--snap PHASES") { |v| opts[:checkpoints] ||= {}; opts[:checkpoints][:phase] = v }
    o.on("--snap-dir DIR") { |v| opts[:checkpoints] ||= {}; opts[:checkpoints][:dir] = v }
    o.on("--resume FILE") { |v| opts[:resume_from] = v }
    o.on("--resume-at NAME") { |v| opts[:resume_at] = v }
    o.on("--stop-after NAME"){ |v| opts[:stop_after] = v }
    o.on("--frontend MODE") { |v| ENV["KUMI_PARSER"] = v }
    o.on("--side-tables", "Enable side table passes (NAST/IRV2 pipeline)") { side_tables = true }
    o.on("--dump STATE_KEY", "Dump and inspect specific analyzer state key") { |v| dump_key = v.to_sym }
  end.parse!(ARGV)

  schema, _ = Kumi::Frontends.load(path: path)
  res = Kumi::Analyzer.analyze!(schema, side_tables: true, **opts)
  
  if dump_key
    if res.state.key?(dump_key)
      puts "=== #{dump_key.upcase} ==="
      puts res.state[dump_key].inspect
    else
      puts "State key '#{dump_key}' not found. Available keys: #{res.state.keys.inspect}"
    end
  else
    puts "Analysis finished without errors."
  end
when "pp"
  kind = ARGV.shift or abort "kumi pp <ast|ir|nast|snast|> <schema-path>"
  path = ARGV.shift or abort "kumi pp #{kind} <schema-path>"
  Kumi::Dev::PrettyPrinter.run(kind, path)

when "golden"
  sub = ARGV.shift or abort "kumi golden <list|update|verify|diff|test> ..."
  name = ARGV.shift if %w[update verify diff test].include?(sub)
  opts = {}
  OptionParser.new do |o|
    o.on("--frontend MODE") { |v| ENV["KUMI_PARSER"] = v }
  end.parse!(ARGV)
  
  case sub
  when "list"   then Kumi::Dev::Golden.list
  when "update" then Kumi::Dev::Golden.update!(name)
  when "verify" then exit(Kumi::Dev::Golden.verify!(name) ? 0 : 1)
  when "diff"   then Kumi::Dev::Golden.diff!(name)
  when "test"
    Kumi::Dev::Golden.update!(name)
    Kumi::Dev::Golden.test_all_codegen!(name)
  when "test_lir"
    Kumi::Dev::Golden.update!(name)
    exit(Kumi::Dev::Golden.test_lir_codegen!(name) ? 0 : 1)
  else
    abort "kumi golden <list|update|verify|diff|test>"
  end

when "diff"
  sub = ARGV.shift or abort "kumi diff <ir> <path> [--golden NAME]"
  if sub == "ir"
    path = ARGV.shift or abort "kumi diff ir <path> [--golden NAME]"
    golden = nil
    OptionParser.new { |o| o.on("--golden NAME") { |v| golden = v } }.parse!(ARGV)
    Kumi::Tools::Golden::Service.diff!(path, golden: golden)
  else
    abort "kumi diff <ir> ..."
  end

when "profile"
  opts = {}
  parser = OptionParser.new do |o|
    o.banner = "Usage: kumi profile <script.rb> [options]"
    o.separator ""
    o.separator "Profiling control:"
    o.on("--phases-only", "Only phase timing (fastest, default)") { opts[:phases_only] = true }
    o.on("--ops", "Include per-operation profiling") { opts[:ops] = true }
    o.on("--sample N", Integer, "Sample 1 out of N operations (reduces overhead)") { |v| opts[:sample] = v }
    o.on("--persistent", "Persistent mode (accumulate across schema creations)") { opts[:persistent] = true }
    o.on("--memory", "Enable memory snapshots") { opts[:memory] = true }
    o.separator ""
    o.separator "Output control:"
    o.on("--output FILE", "Output JSONL file (default: tmp/profile.jsonl)") { |v| opts[:output] = v }
    o.on("--stream", "Stream events to file during execution") { opts[:stream] = true }
    o.on("--truncate", "Truncate output file at start") { opts[:truncate] = true }
    o.on("--quiet", "Don't show analysis, just run") { opts[:quiet] = true }
    o.on("--json [FILE]", "Output final analysis as JSON (optionally to file)") { |v| opts[:json] = true; opts[:json_file] = v if v }
    o.on("--detailed", "Show detailed performance analysis") { opts[:detailed] = true }
    o.on("--limit N", Integer, "Limit detailed results to N entries (default: 15)") { |v| opts[:limit] = v }
    o.separator ""
    o.separator "Examples:"
    o.separator "  kumi profile examples/poc_mc.rb --phases-only --persistent --truncate"
    o.separator "  kumi profile my_script.rb --ops --sample 10 --detailed --limit 20"
    o.separator "  kumi profile test.rb --memory --stream --json profile_analysis.json"
    o.separator "  kumi profile script.rb --ops --persistent --detailed # Full VM analysis"
  end
  parser.parse!(ARGV)
  
  script = ARGV.shift or abort parser.help

  # Run the profiler
  success = Kumi::Dev::ProfileRunner.run(script, opts)
  exit(success ? 0 : 1)

when "codegen"
  sub = ARGV.shift or abort "kumi codegen <list|build|test|verify> ..."
  opts = { targets: %w[ruby] }
  
  OptionParser.new do |o|
    o.on("--targets LIST") { |v| opts[:targets] = v.split(",").map(&:strip) }
    o.on("--output-dir DIR") { |v| opts[:output_dir] = v }
  end.parse!(ARGV)
  
  case sub
  when "list"   then Kumi::Dev::Codegen.list
  when "build" 
    name = ARGV.shift or abort "kumi codegen build <schema_name>"
    Kumi::Dev::Codegen.build!(name, targets: opts[:targets], output_dir: opts[:output_dir])
  when "test"   
    names = ARGV.empty? ? nil : ARGV
    exit(Kumi::Dev::Codegen.test!(*names) ? 0 : 1)
  when "verify" 
    name = ARGV.shift or abort "kumi codegen verify <schema_name>"
    exit(Kumi::Dev::Codegen.verify!(name) ? 0 : 1)
  else
    abort "kumi codegen <list|build|test|verify>"
  end

when "pack"
  sub = ARGV.shift or abort "kumi pack <build|print> ..."
  opts = { targets: %w[ruby], include_ir: false }
  
  OptionParser.new do |o|
    o.on("--schema PATH") { |v| opts[:schema] = v }
    o.on("--out-dir DIR") { |v| opts[:out_dir] = v }
    o.on("--targets LIST"){ |v| opts[:targets] = v.split(",").map(&:strip) }
    o.on("--include-ir")  { opts[:include_ir] = true }
  end.parse!
  
  case sub
  when "build"
    abort "missing --schema" unless opts[:schema]
    abort "missing --out-dir" unless opts[:out_dir]
    puts Kumi::Pack.build(schema: opts[:schema], out_dir: opts[:out_dir],
                          targets: opts[:targets], include_ir: opts[:include_ir])
  when "print"
    abort "missing --schema" unless opts[:schema]
    puts Kumi::Pack.print(schema: opts[:schema], targets: opts[:targets], include_ir: opts[:include_ir])
  else
    abort "kumi pack <build|print>"
  end

else
  abort "usage: kumi <parse|analyze|pp|golden|diff|profile|codegen|pack> ..."
end
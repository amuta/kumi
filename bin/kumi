#!/usr/bin/env ruby
# frozen_string_literal: true

require "bundler/setup"
require "optparse"
require "kumi"

cmd = ARGV.shift or abort "usage: kumi <parse|analyze|pp|golden|diff|profile> ..."

case cmd
when "parse"
  path = ARGV.shift or abort "kumi parse <schema.kumi> [options]"
  opts = {}
  OptionParser.new do |o|
    o.on("--write", "Write golden file instead of diffing") { opts[:write] = true }
    o.on("--update", "Update golden file only if different") { opts[:update] = true }
    o.on("--json", "Use JSON format instead of text") { opts[:json] = true }
    o.on("--no-diff", "Just print output, don't diff") { opts[:no_diff] = true }
    o.on("--trace", "Enable state tracing") { opts[:trace] = true }
    o.on("--snap PHASES", "Snapshot phases") { |v| opts[:snap] = v }
    o.on("--snap-dir DIR", "Snapshot directory") { |v| opts[:snap_dir] = v }
  end.parse!(ARGV)

  success = Kumi::Dev::Parse.run(path, opts)
  exit(success ? 0 : 1)

when "analyze"
  path = ARGV.shift or abort "kumi analyze <schema-path>"
  opts = {}
  dump_key = nil
  OptionParser.new do |o|
    o.on("--trace") { opts[:trace] = true }
    o.on("--snap PHASES") { |v| opts[:checkpoints] ||= {}; opts[:checkpoints][:phase] = v }
    o.on("--snap-dir DIR") { |v| opts[:checkpoints] ||= {}; opts[:checkpoints][:dir] = v }
    o.on("--resume FILE") { |v| opts[:resume_from] = v }
    o.on("--resume-at NAME") { |v| opts[:resume_at] = v }
    o.on("--stop-after NAME"){ |v| opts[:stop_after] = v }
    o.on("--frontend MODE") { |v| ENV["KUMI_PARSER"] = v }
    o.on("--dump STATE_KEY", "Dump and inspect specific analyzer state key") { |v| dump_key = v.to_sym }
  end.parse!(ARGV)

  schema, _ = Kumi::Frontends.load(path: path)
  res = Kumi::Analyzer.analyze!(schema, **opts)
  
  if dump_key
    if res.state.key?(dump_key)
      puts "=== #{dump_key.upcase} ==="
      puts res.state[dump_key].inspect
    else
      puts "State key '#{dump_key}' not found. Available keys: #{res.state.keys.inspect}"
    end
  else
    puts "Analysis finished without errors."
  end
when "pp"
  kind = ARGV.shift or abort "kumi pp <ast|ir|nast|snast> <schema-path>"
  path = ARGV.shift or abort "kumi pp #{kind} <schema-path>"
  Kumi::Dev::PrettyPrinter.run(kind, path)

when "golden"
  sub = ARGV.shift or abort "kumi golden <list|record|verify|diff> ..."
  name = ARGV.shift if %w[record verify diff].include?(sub)
  opts = {}
  OptionParser.new do |o|
    o.on("--frontend MODE") { |v| ENV["KUMI_PARSER"] = v }
  end.parse!(ARGV)
  
  case sub
  when "list"   then Kumi::Dev::Golden.list
  when "record" then Kumi::Dev::Golden.record!(name)
  when "verify" then exit(Kumi::Dev::Golden.verify!(name) ? 0 : 1)
  when "diff"   then Kumi::Dev::Golden.diff!(name)
  else
    abort "kumi golden <list|record|verify|diff>"
  end

when "diff"
  sub = ARGV.shift or abort "kumi diff <ir> <path> [--golden NAME]"
  if sub == "ir"
    path = ARGV.shift or abort "kumi diff ir <path> [--golden NAME]"
    golden = nil
    OptionParser.new { |o| o.on("--golden NAME") { |v| golden = v } }.parse!(ARGV)
    Kumi::Tools::Golden::Service.diff!(path, golden: golden)
  else
    abort "kumi diff <ir> ..."
  end

when "profile"
  opts = {}
  parser = OptionParser.new do |o|
    o.banner = "Usage: kumi profile <script.rb> [options]"
    o.separator ""
    o.separator "Profiling control:"
    o.on("--phases-only", "Only phase timing (fastest, default)") { opts[:phases_only] = true }
    o.on("--ops", "Include per-operation profiling") { opts[:ops] = true }
    o.on("--sample N", Integer, "Sample 1 out of N operations (reduces overhead)") { |v| opts[:sample] = v }
    o.on("--persistent", "Persistent mode (accumulate across schema creations)") { opts[:persistent] = true }
    o.on("--memory", "Enable memory snapshots") { opts[:memory] = true }
    o.separator ""
    o.separator "Output control:"
    o.on("--output FILE", "Output JSONL file (default: tmp/profile.jsonl)") { |v| opts[:output] = v }
    o.on("--stream", "Stream events to file during execution") { opts[:stream] = true }
    o.on("--truncate", "Truncate output file at start") { opts[:truncate] = true }
    o.on("--quiet", "Don't show analysis, just run") { opts[:quiet] = true }
    o.on("--json [FILE]", "Output final analysis as JSON (optionally to file)") { |v| opts[:json] = true; opts[:json_file] = v if v }
    o.on("--detailed", "Show detailed performance analysis") { opts[:detailed] = true }
    o.on("--limit N", Integer, "Limit detailed results to N entries (default: 15)") { |v| opts[:limit] = v }
    o.separator ""
    o.separator "Examples:"
    o.separator "  kumi profile examples/poc_mc.rb --phases-only --persistent --truncate"
    o.separator "  kumi profile my_script.rb --ops --sample 10 --detailed --limit 20"
    o.separator "  kumi profile test.rb --memory --stream --json profile_analysis.json"
    o.separator "  kumi profile script.rb --ops --persistent --detailed # Full VM analysis"
  end
  parser.parse!(ARGV)
  
  script = ARGV.shift or abort parser.help

  # Run the profiler
  success = Kumi::Dev::ProfileRunner.run(script, opts)
  exit(success ? 0 : 1)

else
  abort "usage: kumi <parse|analyze|pp|golden|diff|profile> ..."
end
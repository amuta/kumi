#!/usr/bin/env ruby
# frozen_string_literal: true

require "bundler/setup"
require "optparse"
require "kumi"

cmd = ARGV.shift or abort "usage: kumi <parse|analyze|pp|golden|diff|profile> ..."

case cmd
when "parse"
  path = ARGV.shift or abort "kumi parse <schema.kumi> [options]"
  opts = {}
  OptionParser.new do |o|
    o.on("--write", "Write golden file instead of diffing") { opts[:write] = true }
    o.on("--update", "Update golden file only if different") { opts[:update] = true }
    o.on("--json", "Use JSON format instead of text") { opts[:json] = true }
    o.on("--no-diff", "Just print output, don't diff") { opts[:no_diff] = true }
    o.on("--trace", "Enable state tracing") { opts[:trace] = true }
    o.on("--snap PHASES", "Snapshot phases") { |v| opts[:snap] = v }
    o.on("--snap-dir DIR", "Snapshot directory") { |v| opts[:snap_dir] = v }
  end.parse!(ARGV)

  success = Kumi::Dev::Parse.run(path, opts)
  exit(success ? 0 : 1)

when "analyze"
  path = ARGV.shift or abort "kumi analyze <schema-path>"
  opts = {}
  OptionParser.new do |o|
    o.on("--trace") { opts[:trace] = true }
    o.on("--snap PHASES") { |v| opts[:checkpoints] ||= {}; opts[:checkpoints][:phase] = v }
    o.on("--snap-dir DIR") { |v| opts[:checkpoints] ||= {}; opts[:checkpoints][:dir] = v }
    o.on("--resume FILE") { |v| opts[:resume_from] = v }
    o.on("--resume-at NAME") { |v| opts[:resume_at] = v }
    o.on("--stop-after NAME"){ |v| opts[:stop_after] = v }
    o.on("--frontend MODE") { |v| ENV["KUMI_PARSER"] = v }
  end.parse!(ARGV)

  schema, _ = Kumi::Frontends.load(path: path)
  res = Kumi::Pipeline::AnalyzerRunner.run(schema, opts)
  abort("Analysis errors:\n#{res.errors.inspect}") unless res.ok?
  puts "OK (#{res.stats[:total_ms]}ms)"

when "pp"
  kind = ARGV.shift or abort "kumi pp <ast|ir|nir> <schema-path>"
  path = ARGV.shift or abort "kumi pp #{kind} <schema-path>"
  schema, _ = Kumi::Frontends.load(path: path)

  if kind == "ast"
    puts Kumi::Support::SExpressionPrinter.print(schema)
  elsif kind == "ir"
    res = Kumi::Analyzer.analyze!(schema)
    abort "No IR" unless res.state[:ir_module]
    puts Kumi::Support::IRRender.to_text(res.state[:ir_module], analysis_state: res.state)
  elsif kind == "nir"
    res = Kumi::Analyzer.analyze!(schema)
    abort "No NIR" unless res.state[:nir_module]
    puts Kumi::Support::NIRPrinter.print(res.state[:nir_module])
  else
    abort "unknown: #{kind}"
  end

when "golden"
  sub = ARGV.shift or abort "kumi golden <init|record|verify|diff> ..."
  name = ARGV.shift if %w[init record verify].include?(sub)
  opts = {}
  OptionParser.new do |o|
    o.on("--frontend MODE") { |v| ENV["KUMI_PARSER"] = v }
  end.parse!(ARGV)
  
  case sub
  when "init"   then Kumi::Tools::Golden::Service.init!(name)
  when "record" then Kumi::Tools::Golden::Service.record!(name, **opts)
  when "verify" then exit(Kumi::Tools::Golden::Service.verify!(name, **opts) ? 0 : 1)
  else
    abort "kumi golden <init|record|verify>"
  end

when "diff"
  sub = ARGV.shift or abort "kumi diff <ir> <path> [--golden NAME]"
  if sub == "ir"
    path = ARGV.shift or abort "kumi diff ir <path> [--golden NAME]"
    golden = nil
    OptionParser.new { |o| o.on("--golden NAME") { |v| golden = v } }.parse!(ARGV)
    Kumi::Tools::Golden::Service.diff!(path, golden: golden)
  else
    abort "kumi diff <ir> ..."
  end

when "profile"
  opts = {}
  parser = OptionParser.new do |o|
    o.banner = "Usage: kumi profile <script.rb> [options]"
    o.separator ""
    o.separator "Profiling control:"
    o.on("--phases-only", "Only phase timing (fastest, default)") { opts[:phases_only] = true }
    o.on("--ops", "Include per-operation profiling") { opts[:ops] = true }
    o.on("--sample N", Integer, "Sample 1 out of N operations (reduces overhead)") { |v| opts[:sample] = v }
    o.on("--persistent", "Persistent mode (accumulate across schema creations)") { opts[:persistent] = true }
    o.on("--memory", "Enable memory snapshots") { opts[:memory] = true }
    o.separator ""
    o.separator "Output control:"
    o.on("--output FILE", "Output JSONL file (default: tmp/profile.jsonl)") { |v| opts[:output] = v }
    o.on("--stream", "Stream events to file during execution") { opts[:stream] = true }
    o.on("--truncate", "Truncate output file at start") { opts[:truncate] = true }
    o.on("--quiet", "Don't show analysis, just run") { opts[:quiet] = true }
    o.on("--json [FILE]", "Output final analysis as JSON (optionally to file)") { |v| opts[:json] = true; opts[:json_file] = v if v }
    o.on("--detailed", "Show detailed performance analysis") { opts[:detailed] = true }
    o.on("--limit N", Integer, "Limit detailed results to N entries (default: 15)") { |v| opts[:limit] = v }
    o.separator ""
    o.separator "Examples:"
    o.separator "  kumi profile examples/poc_mc.rb --phases-only --persistent --truncate"
    o.separator "  kumi profile my_script.rb --ops --sample 10 --detailed --limit 20"
    o.separator "  kumi profile test.rb --memory --stream --json profile_analysis.json"
    o.separator "  kumi profile script.rb --ops --persistent --detailed # Full VM analysis"
  end
  parser.parse!(ARGV)
  
  script = ARGV.shift or abort parser.help

  # Run the profiler
  success = Kumi::Dev::ProfileRunner.run(script, opts)
  exit(success ? 0 : 1)

else
  abort "usage: kumi <parse|analyze|pp|golden|diff|profile> ..."
end
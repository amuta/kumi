schema do
  input do
    array :rows do
      array :col do
        integer :alive # 0 or 1
      end
    end
  end

  let :a, input.rows.col.alive

  # axis_offset: 0 = x, 1 = y
  let :n,  fn(:shift, a, -1, policy: :wrap, axis_offset: 1)
  let :s,  fn(:shift, a,  1, policy: :wrap, axis_offset: 1)
  let :w,  fn(:shift, a, -1, policy: :wrap, axis_offset: 0)
  let :e,  fn(:shift, a,  1, policy: :wrap, axis_offset: 0)
  let :nw, fn(:shift, n, -1, policy: :wrap, axis_offset: 0)
  let :ne, fn(:shift, n,  1, policy: :wrap, axis_offset: 0)
  let :sw, fn(:shift, s, -1, policy: :wrap, axis_offset: 0)
  let :se, fn(:shift, s,  1, policy: :wrap, axis_offset: 0)

  let :neighbors, fn(:sum, [n, s, w, e, nw, ne, sw, se])

  # Conway rules
  let :alive, a > 0
  let :n3_alive, neighbors == 3
  let :n2_alive, neighbors == 2
  let :keep_alive, n2_alive & alive

  let :next_alive, n3_alive | keep_alive

  value :next_state, select(next_alive, 1, 0)
end

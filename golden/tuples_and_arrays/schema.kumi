schema do
  input do
    # Input is an array of points, each with an x and y coordinate.
    array :points do
      hash :point do
        integer :x
        integer :y
      end
    end
  end

  # --- Part 1: Element-wise Logic ---

  # First, create an element-wise boolean mask. This will be an array of booleans
  # the same size as the input 'points' array.
  trait :x_is_large, input.points.point.x > 100

  # Next, use the mask to perform an element-wise selection.
  # For each point, it will pick `x` if the condition is true, otherwise it picks `y`.
  # The result, `selected_value`, is another array.
  value :selected_value, select(x_is_large, input.points.point.x, input.points.point.y)

  # --- Part 2: Vectorized Fold ---

  # This is the most complex step. It mixes a tuple operation (a Fold)
  # with element-wise processing.
  # For EACH point in the array, Kumi will:
  #   1. Create a temporary 2-element tuple: `[selected_value_for_point, x_for_point]`
  #   2. Perform a `max` reduction on that small tuple (a Fold).
  # The result, `final_value_per_point`, is a new array containing the result of each fold.
  value :final_value_per_point, fn(:max, [selected_value, input.points.point.x])

  # --- Part 3: Final Reduction ---

  # Finally, we take the array produced by the vectorized fold and reduce it
  # to a single scalar value by summing all its elements.
  value :grand_total, fn(:sum, final_value_per_point)
end
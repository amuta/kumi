# frozen_string_literal: true

require "yaml"

module Kumi
  module Core
    module Analyzer
      module Passes
        class LIRRubyCodegenPass < PassBase
          LIR = Kumi::Core::LIR

          def run(_errors)
            @decls = get_state(:lir_optimized_ops_by_decl, required: true)
            emitter = Emitter.new(registry)

            src = +"# Autogenerated by Kumi Codegen\n"
            src << "module SchemaModule\n"
            src << emitter.emit_class_methods(@decls.keys)

            @decls.each do |name, payload|
              src << emitter.emit_declaration(name, Array(payload[:operations]))
            end

            src << emitter.emit_kernels
            src << "end\n"

            files = { "codegen.rb" => src }
            state.with(:ruby_codegen_files, files)
          end

          # Emitter encapsulates the stateful process of turning LIR into a Ruby string.
          class Emitter
            def initialize(registry)
              @registry = registry
              # Emitter state is reset for each method it generates.
              @out = []
              @indent = 0
              @reg_vars = {}
              @stack = []
              @out_containers = []
              @result_depth = 0
            end

            def emit_class_methods(decl_names)
              @indent = 1
              @out = []

              w "def self.from(input_data)"
              w "  instance = Object.new", 2
              w "  instance.extend(self)", 2
              w "  instance.instance_variable_set(:@input, input_data)", 2
              w "  instance", 2
              w "end\n"

              w "def [](name)"
              w "  case name", 2
              decl_names.each do |name|
                w "  when :#{name} then _eval_#{name}", 3
              end
              w "  else raise KeyError, \"Unknown declaration\"", 3
              w "  end", 2
              w "end\n"

              @out.join
            end
            # Inside private class Emitter

            def emit_kernels
              reset_state(1)
              w "private\n"

              # Correctly use the registry to get all ruby kernels
              ruby_kernels = @registry.instance_variable_get(:@kernels)
                                      .values
                                      .select { |k| k.target == :ruby }

              ruby_kernels.sort_by(&:id).each do |kernel|
                fn_name = kernel.fn_id.split(".").last

                # Split the impl into arguments and body
                impl_lines = kernel.impl.strip.split("\n", 2)

                # First line is args, e.g., "(a,b)" -> "a, b"
                args = impl_lines.first.gsub(/[()]/, "").strip

                # The rest is the method body
                body = impl_lines[1..].join("\n").strip

                w "def __#{fn_name}(#{args})", 2
                w body, 3
                w "end\n", 2
              end

              @out.join
            end

            def emit_declaration(name, ops)
              reset_state(1)
              @result_depth = result_depth(ops)

              w "def _eval_#{name}"
              @indent += 1
              w @result_depth.zero? ? "out = nil" : "out = []"
              @out_containers = ["out"]

              ops.each { |ins| emit_ins(ins) }

              w "out"
              @indent -= 1
              w "end\n"

              @out.join
            end

            private

            def result_depth(ops)
              ops.each.inject(0) do |depth, ins|
                case ins.opcode
                when :LoopStart then depth + 1
                when :LoopEnd   then depth - 1
                when :Yield     then return depth
                else depth
                end
              end
            end

            def emit_ins(ins)
              # ... (emission logic is now part of the Emitter class) ...
              # Highlighted change: using the registry for KernelCall
              case ins.opcode
              when :KernelCall
                fn_id = @registry.resolve_function(ins.attributes[:fn])
                fn_name = fn_id.split(".").last
                args = Array(ins.inputs).map { areg(_1) }.join(", ")
                w "#{vreg(ins)} = __#{fn_name}(#{args})"
              # ... (other cases are the same, but now methods of Emitter) ...
              when :Constant
                v = lit(ins)
                w "#{vreg(ins)} = #{v}"
              when :LoadInput
                key = imm_key(ins)
                w "#{vreg(ins)} = @input[#{key.inspect}]"
              when :LoadField
                obj = areg(ins.inputs.first)
                key = imm_key(ins)
                w "#{vreg(ins)} = #{obj}[#{key.inspect}]"
              when :Select
                c, t, f = ins.inputs.map { areg(_1) }
                w "#{vreg(ins)} = (#{c}) ? (#{t}) : (#{f})"
              when :DeclareAccumulator
                name = ins.attributes[:name]
                w "#{name} = #{lit(ins.immediates&.first)}"
              when :Accumulate
                name = ins.attributes[:accumulator]
                fn_id = @registry.resolve_function(ins.attributes[:function])
                fn   = fn_id.split(".").last
                v    = areg(ins.inputs.first)
                w "#{name} = __#{fn}(#{name}, #{v})"
              when :LoadAccumulator
                name = ins.attributes[:name]
                w "#{vreg(ins)} = #{name}"
              when :LoadDeclaration
                callee = ins.immediates.first.value
                w "#{vreg(ins)} = _eval_#{callee}"
              when :LoopStart
                coll = areg(ins.inputs.first)
                el   = to_local(ins.attributes[:as_element])
                ix   = to_local(ins.attributes[:as_index])
                @stack << { el: el, ix: ix }
                w "#{coll}.each_with_index do |#{el}, #{ix}|"
                @indent += 1
                if @stack.length < @result_depth
                  container_name = "out_#{@stack.length}"
                  @out_containers.push(container_name)
                  w "#{container_name} = []"
                end
              when :LoopEnd
                if @stack.length < @result_depth
                  child = @out_containers.pop
                  parent = @out_containers.last
                  w "#{parent} << #{child}"
                end
                @stack.pop
                @indent -= 1
                w "end"
              when :Yield
                v = areg(ins.inputs.first)
                if @result_depth.zero?
                  w "out = #{v}"
                else
                  w "#{@out_containers.last} << #{v}"
                end
              when :MakeTuple
                elements = Array(ins.inputs).map { areg(_1) }.join(", ")
                w "#{vreg(ins)} = [#{elements}]"
              else
                w "# unsupported: #{ins.opcode}"
              end
            end

            # ---- helpers ----
            def lit(x)
              l = x.is_a?(LIR::Literal) ? x : x.immediates&.first
              v = l&.value
              v.is_a?(Symbol) ? v.inspect : v.inspect
            end

            def imm_key(ins) = ins.immediates&.first&.value
            def to_local(sym) = sym.to_s.delete("%")
            def areg(r) = r.nil? ? "nil" : to_local(r)
            def vreg(ins) = to_local(ins.result_register)

            def w(s, indent = @indent)
              @out << ("  " * indent) << s << "\n"
            end

            def reset_state(indent = 0)
              @out.clear
              @indent = indent
              @reg_vars.clear
              @stack.clear
            end
          end
        end
      end
    end
  end
end

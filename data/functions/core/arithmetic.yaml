functions:
  - id: core.abs
    kind: elementwise
    params: [{ name: number }]
    dtype:
      rule: same_as
      param: number
    aliases: ["abs"]

  - id: core.add
    kind: elementwise
    params: [{ name: left_operand }, { name: right_operand }]
    dtype:
      rule: promote
      params: [left_operand, right_operand]
    aliases: ["add"]
    constraint_semantics:
      domain_effect: EXTEND
      pure_combiner: true
      commutativity: true
      associativity: true
      identity: 0
      forward_propagation:
        # If we know left == L and right == R, then result == L + R
        equality: "result = left + right"
        # If result is in [a, b] and left/right in domains, derive tighter bounds
        range: "result_min = left_min + right_min; result_max = left_max + right_max"
      reverse_propagation:
        # If result == V, then left == V - right
        equality: "left = result - right; right = result - left"
        # If result in [a, b] and left in [l1, l2], then right in [a - l2, b - l1]
        range: "left_min = result_min - right_max; left_max = result_max - right_min; right_min = result_min - left_max; right_max = result_max - left_min"

  - id: core.sub
    kind: elementwise
    params: [{ name: left_operand }, { name: right_operand }]
    dtype:
      rule: promote
      params: [left_operand, right_operand]
    aliases: ["sub", "subtract"]

  - id: core.mul:numeric
    kind: elementwise
    params:
      - { name: left_operand, dtype: numeric }
      - { name: right_operand, dtype: numeric }
    dtype:
      rule: promote
      params: [left_operand, right_operand]
    aliases: ["mul", "multiply"]
    constraint_semantics:
      domain_effect: SCALE
      pure_combiner: true
      commutativity: true
      associativity: true
      identity: 1
      forward_propagation:
        # If we know left == L and right == R, then result == L * R
        equality: "result = left * right"
        # For multiplication: result bounds depend on sign of operands
        range: "result = combinations of {left_min*right_min, left_min*right_max, left_max*right_min, left_max*right_max} -> [min, max]"
      reverse_propagation:
        # If result == V and right != 0, then left == V / right
        equality: "left = result / right (if right != 0); right = result / left (if left != 0)"
        # For multiplication: divide by absolute values considering sign changes
        range: "derive from result bounds and operand bounds considering sign combinations"

  - id: core.mul:string_repeat
    kind: elementwise
    params:
      - { name: string_value, dtype: string }
      - { name: repeat_count, dtype: integer }
    dtype:
      rule: scalar
      kind: string
    aliases: ["mul", "multiply"]

  - id: core.pow
    kind: elementwise
    params: [{ name: base }, { name: exponent }]
    dtype:
      rule: promote
      params: [base, exponent]
    aliases: ["pow", "power"]

  - id: core.div
    kind: elementwise
    params: [{ name: left_operand }, { name: right_operand }]
    dtype:
      rule: scalar
      kind: float
    aliases: ["div", "divide"]

  - id: core.mod
    kind: elementwise
    params:
      - { name: left_operand }
      - { name: right_operand }
    dtype:
      rule: promote
      params: [left_operand, right_operand]
    aliases: ["mod", "modulo", "%"]

  - id: core.clamp
    kind: elementwise
    params: [{ name: x }, { name: lo }, { name: hi }]
    dtype:
      rule: same_as
      param: x
    aliases: ["clamp"]
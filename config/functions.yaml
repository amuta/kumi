# Function Registry Configuration
# 
# IMPORTANT: After editing this file, run the compliance test to ensure correctness:
#   bundle exec rspec spec/kumi/config/functions_config_spec.rb
#
# ==================== CORE - SCALAR (elementwise) ====================

- name: core.add
  domain: core
  opset: 1
  class: scalar
  summary: Numeric addition with broadcasting
  signature: ["(),()->()", "(i),(i)->(i)", "(i,j),(i,j)->(i,j)"]
  type_vars: {T: Numeric, U: Numeric}
  dtypes: {result: "promote(T,U)", casting: "same_kind"}
  null_policy: propagate
  algebra: {associative: true, commutative: true, identity: 0}
  monotonicity: {args: [increasing, increasing]}
  vectorization: {mask_aware: true}
  kernels: 
    - backend: ruby
      impl: kumi_add
      priority: 10

- name: core.sub
  domain: core
  opset: 1
  class: scalar
  signature: ["(),()->()", "(i),(i)->(i)", "(i,j),(i,j)->(i,j)"]
  type_vars: {T: Numeric, U: Numeric}
  dtypes: {result: "promote(T,U)", casting: "same_kind"}
  null_policy: propagate
  monotonicity: {args: [increasing, decreasing]}
  kernels:
    - backend: ruby
      impl: kumi_sub
      priority: 10

- name: core.mul
  domain: core
  opset: 1
  class: scalar
  signature: ["(),()->()", "(i),(i)->(i)", "(i,j),(i,j)->(i,j)"]
  type_vars: {T: Numeric, U: Numeric}
  dtypes: {result: "promote(T,U)", casting: "same_kind"}
  null_policy: propagate
  algebra: {associative: true, commutative: true, identity: 1, annihilator: 0}
  monotonicity: {args: [increasing, increasing], condition: positive_args}
  kernels:
    - backend: ruby
      impl: kumi_mul
      priority: 10

- name: core.div
  domain: core
  opset: 1
  class: scalar
  signature: ["(),()->()", "(i),(i)->(i)", "(i,j),(i,j)->(i,j)"]
  type_vars: {T: Numeric, U: Numeric}
  dtypes: {result: "promote_float(T,U)", casting: "same_kind"}
  null_policy: propagate

  kernels:
    - backend: ruby
      impl: kumi_div
      priority: 10

- name: core.mod
  domain: core
  opset: 1
  class: scalar
  signature: ["(),()->()", "(i),(i)->(i)", "(i,j),(i,j)->(i,j)"]
  type_vars: {T: IntLike, U: IntLike}
  dtypes: {result: "promote(T,U)"}
  null_policy: propagate
  kernels:
    - backend: ruby
      impl: kumi_mod
      priority: 10

- name: core.pow
  domain: core
  opset: 1
  class: scalar
  signature: ["(),()->()", "(i),(i)->(i)", "(i,j),(i,j)->(i,j)"]
  type_vars: {T: Numeric, U: Numeric}
  dtypes: {result: "promote_float(T,U)"}
  null_policy: propagate
  kernels:
    - backend: ruby
      impl: kumi_pow
      priority: 1

# ==================== CORE - COMPARISONS / LOGICAL ====================

- name: core.eq
  domain: core
  opset: 1
  class: scalar
  signature: ["(),()->()", "(i),(i)->(i)", "(i,j),(i,j)->(i,j)"]
  type_vars: {T: Any, U: Any}
  dtypes: {result: "bool"}
  null_policy: propagate
  semantics: {family: comparison, relation: equality, reflexive: true, symmetric: true, transitive: true, negation: core.ne}
  kernels:
    - backend: ruby
      impl: kumi_eq
      priority: 10

- name: core.ne
  domain: core
  opset: 1
  class: scalar
  signature: ["(),()->()", "(i),(i)->(i)", "(i,j),(i,j)->(i,j)"]
  type_vars: {T: Any, U: Any}
  dtypes: {result: "bool"}
  null_policy: propagate
  semantics: {family: comparison, relation: disequality, negates: core.eq}
  kernels:
    - backend: ruby
      impl: kumi_ne
      priority: 10

- name: core.lt
  domain: core
  opset: 1
  class: scalar
  signature: ["(),()->()", "(i),(i)->(i)"]
  type_vars: {T: Orderable, U: Orderable}
  dtypes: {result: "bool"}
  null_policy: propagate
  semantics: {family: comparison, relation: total_order, transitive: true, trichotomy: true, dual_of: core.ge, implies: [core.le, core.ne]}
  kernels:
    - backend: ruby
      impl: kumi_lt
      priority: 10

- name: core.le
  domain: core
  opset: 1
  class: scalar
  signature: ["(),()->()", "(i),(i)->(i)"]
  type_vars: {T: Orderable, U: Orderable}
  dtypes: {result: "bool"}
  null_policy: propagate
  semantics: {family: comparison, relation: total_order, reflexive: true, antisymmetric: true, transitive: true, dual_of: core.ge, implies: [core.lt, core.eq]}
  kernels:
    - backend: ruby
      impl: kumi_le
      priority: 10

- name: core.gt
  domain: core
  opset: 1
  class: scalar
  signature: ["(),()->()", "(i),(i)->(i)"]
  type_vars: {T: Orderable, U: Orderable}
  dtypes: {result: "bool"}
  null_policy: propagate
  semantics: {family: comparison, relation: total_order, transitive: true, trichotomy: true, dual_of: core.le, implies: [core.ge, core.ne]}
  kernels:
    - backend: ruby
      impl: kumi_gt
      priority: 10

- name: core.ge
  domain: core
  opset: 1
  class: scalar
  signature: ["(),()->()", "(i),(i)->(i)"]
  type_vars: {T: Orderable, U: Orderable}
  dtypes: {result: "bool"}
  null_policy: propagate
  semantics: {family: comparison, relation: total_order, reflexive: true, antisymmetric: true, transitive: true, dual_of: core.lt, implies: [core.gt, core.eq]}
  kernels:
    - backend: ruby
      impl: kumi_ge
      priority: 10

- name: core.and
  domain: core
  opset: 1
  class: scalar
  signature: ["(),()->()", "(i),(i)->(i)"]
  type_vars: {B1: Bool, B2: Bool}
  dtypes: {result: "bool"}
  null_policy: propagate
  algebra: {family: boolean_op, op: and, associative: true, commutative: true, idempotent: true, identity: true, annihilator: false}
  vectorization: {short_circuit: left_to_right, mask_aware: true}
  kernels:
    - backend: ruby
      impl: kumi_and
      priority: 10

- name: core.or
  domain: core
  opset: 1
  class: scalar
  signature: ["(),()->()", "(i),(i)->(i)"]
  type_vars: {B1: Bool, B2: Bool}
  dtypes: {result: "bool"}
  null_policy: propagate
  algebra: {family: boolean_op, op: or, associative: true, commutative: true, idempotent: true, identity: false, annihilator: true}
  vectorization: {short_circuit: left_to_right, mask_aware: true}
  kernels:
    - backend: ruby
      impl: kumi_or
      priority: 10

- name: core.not
  domain: core
  opset: 1
  class: scalar
  signature: ["()->()", "(i)->(i)"]
  type_vars: {B: Bool}
  dtypes: {result: "bool"}
  null_policy: propagate
  algebra: {family: boolean_op, op: not, involutive: true, de_morgan_dual: or}
  kernels:
    - backend: ruby
      impl: kumi_not
      priority: 10

- name: core.if
  domain: core
  opset: 1
  class: scalar
  summary: Ternary conditional with broadcasting of then/else
  signature:
    - "(),(),(),()->()"
    - "(i),(i),(i)->(i)"
    - "(i),(),()->(i)"
    - "(),(i),()->(i)"
    - "(),(),()->()"
  type_vars: {B: Bool, T: Any, U: Any}
  dtypes: {result: "unify(T,U)"}
  null_policy: propagate
  vectorization: {mask_aware: true}
  kernels:
    - backend: ruby
      impl: kumi_if
      priority: 10

# ==================== AGGREGATES (reduce last axis in signature) ==============

- name: agg.sum
  domain: core
  opset: 1
  class: aggregate
  signature: 
    - "(i)->()" 
    - "(i,j)->(i)"
  type_vars: {T: Numeric}
  dtypes: {result: "promote(T)"}
  null_policy: skip
  options: {min_count: 0}
  algebra: {associative: true, commutative: true, identity: 0}
  kernels:
    - backend: ruby
      impl: kumi_sum
      priority: 10

- name: agg.min
  domain: core
  opset: 1
  class: aggregate
  signature: ["(i)->()", "(i,j)->(i)"]
  type_vars: {T: Orderable}
  dtypes: {result: "T"}
  null_policy: skip
  kernels:
    - backend: ruby
      impl: kumi_min
      priority: 10

- name: agg.max
  domain: core
  opset: 1
  class: aggregate
  signature: ["(i)->()", "(i,j)->(i)"]
  type_vars: {T: Orderable}
  dtypes: {result: "T"}
  null_policy: skip
  kernels:
    - backend: ruby
      impl: kumi_max
      priority: 10

- name: agg.mean
  domain: core
  opset: 1
  class: aggregate
  signature: ["(i)->()", "(i,j)->(i)"]
  type_vars: {T: Numeric}
  dtypes: {result: "float"}
  null_policy: skip
  options: {min_count: 0}
  kernels:
    - backend: ruby
      impl: kumi_mean
      priority: 10

- name: core.any?
  domain: core
  opset: 1
  class: aggregate
  signature: ["(i)->()", "(i,j)->(i)"]
  type_vars: {T: Any}
  dtypes: {result: "bool"}
  null_policy: skip
  algebra: {boolean_aggregate: true}
  kernels:
    - backend: ruby
      impl: kumi_any
      priority: 10

- name: core.none?
  domain: core
  opset: 1
  class: aggregate
  signature: ["(i)->()", "(i,j)->(i)"]
  type_vars: {T: Any}
  dtypes: {result: "bool"}
  null_policy: skip
  algebra: {boolean_aggregate: true}
  kernels:
    - backend: ruby
      impl: kumi_none
      priority: 10

- name: core.all?
  domain: core
  opset: 1
  class: aggregate
  signature: ["(i)->()", "(i,j)->(i)"]
  type_vars: {T: Any}
  dtypes: {result: "bool"}
  null_policy: skip
  algebra: {boolean_aggregate: true}
  kernels:
    - backend: ruby
      impl: kumi_all
      priority: 10

# ==================== STRUCTURE / SHAPE / JOIN ================================

- name: struct.join
  domain: struct
  opset: 1
  class: structure
  summary: Align inputs by axes using zip or product
  signature: ["(i),(i)->(i)@zip", "(i),(j)->(i,j)@product"]
  null_policy: error_on_missing
  semantics: {family: structural, role: data_manipulation}
  kernels:
    - backend: ruby
      impl: join_zip
      when: {policy: zip}
      priority: 10
    - backend: ruby
      impl: join_product
      when: {policy: product}
      priority: 10

- name: struct.align_to
  domain: struct
  opset: 1
  class: structure
  signature: ["(i)->(i)", "(i,j)->(i,j)"]
  traits: {reorders: false}
  null_policy: error_on_missing
  semantics: {family: structural, role: data_manipulation}
  kernels:
    - backend: ruby
      impl: align_to
      priority: 10

- name: struct.lift
  domain: struct
  opset: 1
  class: structure
  signature: ["(i)->(i)", "(i,j)->(i,j)"]
  summary: Group flat rows back to nested collections based on indices
  semantics: {family: structural, role: data_manipulation}
  kernels:
    - backend: ruby
      impl: lift
      priority: 10

- name: struct.flatten
  domain: struct
  opset: 1
  class: structure
  signature: ["(i,j)->(k)"]
  shape_fn: "flatten_axes(i,j)->k"
  semantics: {family: structural, role: data_manipulation}
  kernels:
    - backend: ruby
      impl: flatten
      priority: 10

- name: struct.take
  domain: struct
  opset: 1
  class: structure
  signature: ["(i),(i)->(i)"]  # take(values, indices) elemwise
  type_vars: {T: Any}
  dtypes: {result: "T"}
  null_policy: error
  semantics: {family: structural, role: data_access}
  kernels:
    - backend: ruby
      impl: kumi_take
      priority: 10

- name: struct.size
  domain: struct
  opset: 1
  class: aggregate
  signature: ["(i)->()", "(i,j)->()"]
  dtypes: {result: "int"}
  null_policy: error
  semantics: {family: structural, role: introspection}
  kernels:
    - backend: ruby
      impl: size
      priority: 10

# ==================== MASK / CONDITIONAL ======================================

- name: mask.where
  domain: mask
  opset: 1
  class: scalar
  summary: Ternary select with broadcasting of then/else
  signature:
    - "(i),(i),(i)->(i)"
    - "(i),(),()->(i)"
    - "(),(i),()->(i)"
    - "(),(),()->()"
  type_vars: {B: Bool, T: Any, U: Any}
  dtypes: {result: "unify(T,U)"}
  null_policy: propagate
  vectorization: {mask_aware: true, short_circuit: left_to_right}
  kernels:
    - backend: ruby
      impl: where
      priority: 10

# ==================== STRING (minimal) ========================================

- name: string.concat
  domain: string
  opset: 1
  class: scalar
  variadic: true
  zip_policy: zip
  signature: ["->()", "(i)->(i)"]
  type_vars: {S: String}
  dtypes: {result: "string"}
  null_policy: propagate
  kernels:
    - backend: ruby
      impl: str_concat
      priority: 10

- name: string.join
  domain: string
  opset: 1
  class: aggregate
  signature: ["(i),()->()", "(i,j),()->(i)"]
  type_vars: {S: String, T: String}
  dtypes: {result: "string"}
  null_policy: propagate
  kernels:
    - backend: ruby
      impl: str_join
      priority: 10

- name: string.length
  domain: string
  opset: 1
  class: vector
  signature: ["(i)->(i)", "()->()"]
  type_vars: {S: String}
  dtypes: {result: "int"}
  null_policy: propagate
  kernels:
    - backend: ruby
      impl: str_length
      priority: 10

# ==================== DATETIME (minimal) ======================================

- name: datetime.add_days
  domain: datetime
  opset: 1
  class: scalar
  signature: ["(),()->()", "(i),(i)->(i)"]
  type_vars: {D: DateLike, N: IntLike}
  dtypes: {result: "datetime"}
  null_policy: propagate
  kernels:
    - backend: ruby
      impl: dt_add_days
      priority: 10

- name: datetime.diff_days
  domain: datetime
  opset: 1
  class: scalar
  signature: ["(),()->()", "(i),(i)->(i)"]
  type_vars: {D1: DateLike, D2: DateLike}
  dtypes: {result: "int"}
  null_policy: propagate
  kernels:
    - backend: ruby
      impl: dt_diff_days
      priority: 10

# ==================== ARRAY / STRUCTURE ACCESSORS =============================

- name: array.get
  domain: struct
  opset: 1
  class: scalar
  signature:
    - "(),()->()"      # scalar array, scalar index
    - "(i),()->(i)"    # vector array, scalar index
    - "(),(i)->(i)"    # scalar array, vector index (same-scope broadcast)
  type_vars: {A: Any}
  dtypes: {result: "A"}
  null_policy: error
  semantics: {family: structural, role: data_access}
  kernels:
    - backend: ruby
      impl: array_get
      priority: 10

- name: struct.get
  domain: struct
  opset: 1
  class: scalar
  signature:
    - "(),()->()"      # struct, key
    - "(i),()->(i)"    # vector of structs, scalar key
    - "(),(i)->(i)"    # struct, vector of keys
  type_vars: {K: StringLike}
  dtypes: {result: "any"}
  null_policy: error
  semantics: {family: structural, role: data_access}
  kernels:
    - backend: ruby
      impl: struct_get
      priority: 10

- name: array.contains
  domain: struct
  opset: 1
  class: scalar
  signature: ["(),()->()", "(i),()->(i)"]
  type_vars: {A: Any}
  dtypes: {result: "bool"}
  null_policy: propagate
  semantics: {family: structural, role: membership_test}
  kernels:
    - backend: ruby
      impl: array_contains
      priority: 10

- name: string.contains
  domain: string
  opset: 1
  class: scalar
  signature: ["(),()->()", "(i),()->(i)"]
  type_vars: {S: String}
  dtypes: {result: "bool"}
  null_policy: propagate
  kernels:
    - backend: ruby
      impl: str_contains
      priority: 10


# ==================== CORE - ELEMENTWISE (keeps fn(:max/:min) working) =======

- name: core.max
  domain: core
  opset: 1
  class: scalar
  summary: Elementwise maximum with broadcasting
  signature: ["(),()->()", "(i),(i)->(i)", "(i,j),(i,j)->(i,j)"]
  type_vars: {T: Orderable, U: Orderable}
  dtypes: {result: "promote(T,U)", casting: "same_kind"}
  null_policy: propagate
  kernels:
    - backend: ruby
      impl: kumi_maximum    # distinct from agg.max's kumi_max
      priority: 10

- name: core.min
  domain: core
  opset: 1
  class: scalar
  summary: Elementwise minimum with broadcasting
  signature: ["(),()->()", "(i),(i)->(i)", "(i,j),(i,j)->(i,j)"]
  type_vars: {T: Orderable, U: Orderable}
  dtypes: {result: "promote(T,U)", casting: "same_kind"}
  null_policy: propagate
  kernels:
    - backend: ruby
      impl: kumi_minimum    # distinct from agg.min's kumi_min
      priority: 10

- name: core.clip
  domain: core
  opset: 1
  class: scalar
  summary: Clamp x into [lo, hi] elementwise
  signature:
    - "(),(),()->()"
    - "(i),(),()->(i)"
    - "(),(i),()->(i)"
    - "(i),(i),()->(i)"
    - "(i),(i),(i)->(i)"
    - "(i,j),(i,j),(i,j)->(i,j)"
  type_vars: {T: Orderable, U: Orderable, V: Orderable}
  dtypes: {result: "promote(promote(T,U),V)", casting: "same_kind"}
  null_policy: propagate
  kernels:
    - backend: ruby
      impl: kumi_clip
      priority: 10

# ==================== CORE - VECTOR TRANSFORMS ================================

- name: core.diff
  domain: core
  opset: 1
  class: vector
  summary: First discrete difference along the last axis
  signature:
    - "(i)->(k)"            # 1-D
    - "(s,i)->(s,k)"        # batched: per-status diff
  shape_fn: "diff_last->k"   # k = len(last_axis) - 1
  type_vars: {T: Numeric}
  dtypes: {result: "T"}
  null_policy: propagate
  options: {axis: -1}
  kernels:
    - backend: ruby
      impl: kumi_diff
      priority: 10

- name: core.cumsum
  domain: core
  opset: 1
  class: vector
  summary: Cumulative sum along the last axis
  signature: ["(i)->(i)", "(i,j)->(i,j)"]
  type_vars: {T: Numeric}
  dtypes: {result: "promote(T)"}
  null_policy: propagate
  options: {axis: -1}
  kernels:
    - backend: ruby
      impl: kumi_cumsum
      priority: 10

# ==================== STRUCTURE / SHAPE =======================================

- name: struct.concatenate
  domain: struct
  opset: 1
  class: structure
  summary: Concatenate arrays along the last axis
  signature: ["(i),(i)->(k)", "(i,j),(i,j)->(i,k)"]
  shape_fn: "concat_last->k"   # k = len_last(a) + len_last(b)
  type_vars: {T: Any}
  dtypes: {result: "T"}
  null_policy: propagate
  options: {axis: -1}
  constraints:
    - "Inputs must match in all non-concatenated axes"
  kernels:
    - backend: ruby
      impl: kumi_concatenate
      priority: 10

- name: struct.prepend
  domain: struct
  opset: 1
  class: structure
  summary: Prepend a scalar to a 1-D array (sugar over concatenate)
  signature: 
      - "(),(i)->(k)"         # existing 1-D
      - "(),(s,i)->(s,k)"     # batched statuses S x I -> S x (I+1)
  shape_fn: "concat_last->k"
  type_vars: {T: Any}
  dtypes: {result: "T"}
  null_policy: propagate
  kernels:
    - backend: ruby
      impl: kumi_prepend
      priority: 5

- name: struct.searchsorted
  domain: struct
  opset: 1
  class: vector
  summary: Indices where values should be inserted to maintain order
  signature:
    - "(i),()->()"       # edges 1-D, scalar v
    - "(i),(j)->(j)"     # edges 1-D, vector v
    - "(s,i),(s)->(s)"   # batched: S rows of edges, S scalars v
  type_vars: {E: Orderable, V: Orderable, S: Any}
  dtypes: {result: "int"}
  null_policy: error
  options: {side: right}     # :left | :right
  constraints:
    - "edges must be 1-D nondecreasing"
    - "edges must match in length with values"
    - "values must be 1-D"
  kernels:
    - backend: ruby
      impl: kumi_searchsorted
      priority: 10

- name: struct.take_along_axis
  domain: struct
  opset: 1
  class: structure
  summary: Take values by indices along the last axis
  signature: ["(i),(i)->(i)", "(i,j),(i,j)->(i,j)"]
  type_vars: {T: Any}
  dtypes: {result: "T"}
  null_policy: error
  options: {axis: -1}
  constraints:
    - "indices within bounds of last axis"
    - "values/indices match on non-indexed axes"
  kernels:
    - backend: ruby
      impl: kumi_take_along_axis
      priority: 10

# ==================== AGGREGATES (indices) ====================================

- name: agg.argmax
  domain: core
  opset: 1
  class: aggregate
  summary: Index of the maximum along the last axis
  signature: ["(i)->()", "(i,j)->(i)"]
  type_vars: {T: Orderable}
  dtypes: {result: "int"}
  null_policy: skip
  options: {axis: -1, tie_break: first}  # or :last
  kernels:
    - backend: ruby
      impl: kumi_argmax
      priority: 10

- name: agg.argmin
  domain: core
  opset: 1
  class: aggregate
  summary: Index of the minimum along the last axis
  signature: ["(i)->()", "(i,j)->(i)"]
  type_vars: {T: Orderable}
  dtypes: {result: "int"}
  null_policy: skip
  options: {axis: -1, tie_break: first}
  kernels:
    - backend: ruby
      impl: kumi_argmin
      priority: 10

# ==================== MISSING FUNCTIONS (IDENTIFIED BY TEST ANALYSIS) ========
- name: core.abs
  domain: core
  opset: 1
  class: scalar
  summary: Absolute value
  signature: ["(),()->()", "(i)->(i)", "(i,j)->(i,j)"]
  type_vars: {T: Numeric}
  dtypes: {result: "T"}
  null_policy: propagate
  kernels:
    - backend: ruby
      impl: kumi_abs
      priority: 10

- name: core.round
  domain: core
  opset: 1
  class: scalar
  summary: Round number to specified decimal places
  signature: ["(),()->()", "(f)->(f)", "(f),(i)->(f)", "(i,j),(i,j)->(i,j)"]
  type_vars: {T: Numeric, U: Integer}
  dtypes: {result: "float"}
  null_policy: propagate
  kernels:
    - backend: ruby
      impl: kumi_round
      priority: 10

- name: struct.fetch
  domain: core
  opset: 1
  class: scalar
  summary: Fetch value from hash/object by key
  signature: ["(),()->()", "(i),()->(i)"]
  type_vars: {T: Any, K: Any}
  dtypes: {result: "A"}
  null_policy: propagate
  kernels:
    - backend: ruby
      impl: kumi_fetch
      priority: 10

- name: string.upcase
  domain: core
  opset: 1
  class: scalar
  summary: Convert string to uppercase
  signature: ["(),()->()", "(i)->(i)"]
  type_vars: {T: String}
  dtypes: {result: "string"}
  null_policy: propagate
  kernels:
    - backend: ruby
      impl: kumi_upcase
      priority: 10

- name: agg.first
  domain: core
  opset: 1
  class: aggregate
  summary: First element of array
  signature: ["(i)->()", "(i,j)->(i)"]
  type_vars: {T: Numeric}
  dtypes: {result: "T"}
  null_policy: skip
  kernels:
    - backend: ruby
      impl: kumi_first
      priority: 10

# frozen_string_literal: true

require "spec_helper"

RSpec.describe "Join Operations Integration" do
  describe "VM-level join functionality" do
    # This spec tests the join operations at the VM/IR level
    # End-to-end DSL support requires PR B (LowerToIR emitting :join operations)
    
    context "direct IR execution with join operations" do
      def ir_module(decls)
        Kumi::Core::IR::Module.new(inputs: {}, decls: decls)
      end

      def ir_decl(name, ops)
        Kumi::Core::IR::Decl.new(name: name, kind: :value, shape: nil, ops: ops)
      end

      def ir_op(tag, attrs = {}, args = [])
        Kumi::Core::IR::Op.new(tag: tag, attrs: attrs, args: args)
      end

      def registry
        Kumi::Registry.functions
      end

      it "executes cross-scope joins at the VM level" do
        # Use analyzer to generate proper IR from schema
        state = analyze_up_to(:ir_module) do
          input do
            array :left_items, elem: { type: :string }
            array :right_items, elem: { type: :integer }
          end
          
          # This should trigger cross-scope join detection if needed
          value :cross_scope_result, fn(:concat, input.left_items, input.right_items)
        end
        
        ir = state[:ir_module]
        
        # Print the actual IR structure the analyzer produces
        puts "\n=== JOIN OPERATIONS IR ==="
        ir.decls.each_with_index do |decl, i|
          puts "Decl #{i}: #{decl.name} (#{decl.kind})"
          decl.ops.each_with_index do |op, j|
            puts "  Op #{j}: #{op.tag} #{op.attrs.inspect} args=#{op.args}"
          end
        end
        puts "=========================="
        
        # Assert on the actual structure generated by the analyzer
        expect(ir).to be_a(Kumi::Core::IR::Module)
        expect(ir.decls).not_to be_empty
        
        cross_scope_decl = ir.decls.find { |d| d.name == :cross_scope_result }
        expect(cross_scope_decl).not_to be_nil
        
        # Verify that string.concat function is properly qualified
        map_ops = cross_scope_decl.ops.select { |op| op.tag == :map }
        expect(map_ops).not_to be_empty
        map_ops.each do |op|
          expect(op.attrs[:fn]).to eq("string.concat")
        end
      end

      xit "handles mathematical operations on joined vectors (requires cross-scope join support)" do
        # This test requires PR B to implement cross-scope join operations
        # The legacy manual IR construction has been replaced with analyzer-generated IR
        # which correctly uses qualified function names, but the analyzer doesn't yet
        # support cross-scope operations
      end
    end
  end

  describe "Current DSL limitations (requires PR B)" do
    # These tests document what currently fails and should work after PR B
    
    context "with cross-scope operations in DSL" do
      it "currently fails with cross-scope map without join error" do
        expect do
          Module.new do
            extend Kumi::Schema
            
            schema do
              input do
                array :left_items do
                  string :name
                end
                array :right_items do  
                  string :category
                end
              end
              
              # This currently fails but should work after PR B
              value :combined, fn(:concat, input.left_items.name, input.right_items.category)
            end
          end
        end.to raise_error(Kumi::Core::Errors::SemanticError, /cross-scope map without join/)
      end

      it "currently fails with arithmetic operations across scopes" do
        expect do
          Module.new do
            extend Kumi::Schema
            
            schema do
              input do
                array :values1 do
                  integer :x
                end
                array :values2 do
                  integer :y
                end
              end
              
              # This currently fails but should work after PR B
              value :sums, input.values1.x + input.values2.y
            end
          end
        end.to raise_error(Kumi::Core::Errors::SemanticError, /cross-scope map without join/)
      end
    end
  end

  describe "Same-scope operations (currently supported)" do
    context "with operations within the same array scope" do
      module SameScopeSchema
        extend Kumi::Schema
        
        schema do
          input do
            array :items do
              string :name
              integer :value
              float :price
            end
          end
          
          # These work because they're all from the same scope
          value :combined_info, fn(:concat, input.items.name, ": $", input.items.price)
          value :total_cost, input.items.value * input.items.price
          value :item_summary, [input.items.name, input.items.value, input.items.price]
        end
      end

      let(:same_scope_data) do
        {
          items: [
            { name: "Item1", value: 2, price: 10.5 },
            { name: "Item2", value: 3, price: 15.0 }
          ]
        }
      end

      it "performs operations within the same array scope" do
        result = SameScopeSchema.from(same_scope_data)
        
        expect(result[:combined_info]).to eq(["Item1: $10.5", "Item2: $15.0"])
        expect(result[:total_cost]).to eq([21.0, 45.0])
        expect(result[:item_summary]).to eq([
          ["Item1", 2, 10.5],
          ["Item2", 3, 15.0]
        ])
      end
    end
  end
end
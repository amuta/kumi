# Kumi

[![CI](https://github.com/amuta/kumi/workflows/CI/badge.svg)](https://github.com/amuta/kumi/actions)
[![Gem Version](https://badge.fury.io/rb/kumi.svg)](https://badge.fury.io/rb/kumi)

Kumi is a declarative calculation DSL for Ruby. It compiles business rules into a typed dependency graph with vector semantics, performs static validation at definition time, lowers into a portable Low-level IR (LIR), and either executes deterministically or code-generates standalone Ruby and JavaScript.

Itâ€™s built for domains where correctness and explainability matter: finance, tax, pricing, insurance, payroll, and other rule-heavy systems.

---

## Example: U.S. Federal Taxes

```ruby
module FederalTax2024
  extend Kumi::Schema
  
  schema do
    input do
      float  :income
      string :filing_status, domain: %w[single married_joint]
    end
    
    trait :single,  input.filing_status == "single"
    trait :married, input.filing_status == "married_joint"
    
    value :std_deduction do
      on single,  14_600
      on married, 29_200
      base        21_900
    end
    
    value :taxable_income, fn(:max, [input.income - std_deduction, 0])
    
    value :fed_breaks do
      on single,  [11_600, 47_150, 100_525, 191_950, 243_725, 609_350, Float::INFINITY]
      on married, [23_200, 94_300, 201_050, 383_900, 487_450, 731_200, Float::INFINITY]
    end
    
    value :fed_rates, [0.10, 0.12, 0.22, 0.24, 0.32, 0.35, 0.37]
    value :fed_calc,  fn(:piecewise_sum, taxable_income, fed_breaks, fed_rates)
    value :fed_tax,   fed_calc[0]
    
    value :ss_tax, fn(:min, [input.income, 168_600]) * 0.062
    value :medicare_tax, input.income * 0.0145
    
    value :total_tax, fed_tax + ss_tax + medicare_tax
    value :after_tax, input.income - total_tax
  end
end

result = FederalTax2024.from(income: 100_000, filing_status: "single")
result[:total_tax]   # => 21,491.00
result[:after_tax]   # => 78,509.00
```

---

Add this section to the README. Paste as-is.

````markdown
## Codegen: Ruby and JavaScript

Kumi executes via the analyzer/interpreter or emits standalone code.

- Ruby backend: pure Ruby module. No Kumi at runtime.
- JavaScript backend: ES module for Node or browsers.

<details>
<summary><strong>Schema</strong></summary>

```ruby
module Cart
  extend Kumi::Schema

  schema do
    input do
      array :items do
        float   :price
        integer :qty
      end
      float :discount
    end

    # Elementwise
    value :items_subtotal,   input.items.price * input.items.qty
    value :items_discounted, input.items.price * (1.0 - input.discount)

    # Boolean mask + branch at same stamp
    value :items_is_big,     input.items.price > 100.0
    value :items_effective,  select(items_is_big, items_subtotal * 0.9, items_subtotal)

    # Reductions (rank 1 -> rank 0)
    value :total_qty,            fn(:sum, input.items.qty)
    value :cart_total,           fn(:sum, items_subtotal)
    value :cart_total_effective, fn(:sum, items_effective)
  end
end
````

</details>

<details>
<summary><strong>Optimized LIR (lowered IR)</strong></summary>

```bash
# ...

(Declaration cart_total
  %acc_36 = decl_acc :: float
  %t37 = load_input "items" :: array
  loop items id=L6 in %t37 as el=%items_el_38, idx=%items_i_39
    %t57 = load_field items_el_38["price"] :: float
    %t58 = load_field items_el_38["qty"] :: integer
    %t59 = call core.mul(%t57, %t58) :: float
    %acc_36 = acc_add agg.sum(%acc_36, %t59) :: float
  end_loop
  %t41 = acc_load %acc_36 :: float
  yield %t41
)
(Declaration cart_total_effective
  %acc_42 = decl_acc :: float
  %t43 = load_input "items" :: array
  %t69 = const 100.0 :: float
  %t63 = const 0.9 :: float
  loop items id=L7 in %t43 as el=%items_el_44, idx=%items_i_45
    %t68 = load_field items_el_44["price"] :: float
    %t73 = load_field items_el_44["qty"] :: integer
    %t70 = call core.gt(%t68, %__immediate_placeholder__) :: boolean
    %t74 = call core.mul(%t68, %t73) :: float
    %t64 = call core.mul(%t74, %__immediate_placeholder__) :: float
    %t66 = select %t70, %t64, %t74 :: float
    %acc_42 = acc_add agg.sum(%acc_42, %t66) :: float
  end_loop
  %t47 = acc_load %acc_42 :: float
  yield %t47
)
```

</details>

<details>
<summary><strong>Generated Ruby (excerpt)</strong></summary>

```ruby
# Autogenerated by Kumi Codegen
module Kumi::Compiled::KUMI_ab5095ff65347e715e158fac0f8baa864bf96c953ee33be671467d16a6202958
  #  ...

  def _items_effective(input = @input)
    out = []
    t21 = input["items"] || input[:items]
    t21.each_with_index do |items_el_22, _items_i_23|
      t49 = items_el_22["price"] || items_el_22[:price]
      t54 = items_el_22["qty"] || items_el_22[:qty]
      t51 = t49 > 100.0
      t55 = t49 * t54
      t27 = t55 * 0.9
      t29 = t51 ? t27 : t55
      out << t29
    end
    out
  end

  def _total_qty(input = @input)
    acc_30 = 0.0
    t31 = input["items"] || input[:items]
    t31.each_with_index do |items_el_32, _items_i_33|
      t34 = items_el_32["qty"] || items_el_32[:qty]
      acc_30 += t34
    end
    acc_30
  end

  def _cart_total(input = @input)
    acc_36 = 0.0
    t37 = input["items"] || input[:items]
    t37.each_with_index do |items_el_38, _items_i_39|
      t57 = items_el_38["price"] || items_el_38[:price]
      t58 = items_el_38["qty"] || items_el_38[:qty]
      t59 = t57 * t58
      acc_36 += t59
    end
    acc_36
  end

  def _cart_total_effective(input = @input)
    acc_42 = 0.0
    t43 = input["items"] || input[:items]
    t43.each_with_index do |items_el_44, _items_i_45|
      t68 = items_el_44["price"] || items_el_44[:price]
      t73 = items_el_44["qty"] || items_el_44[:qty]
      t70 = t68 > 100.0
      t74 = t68 * t73
      t64 = t74 * 0.9
      t66 = t70 ? t64 : t74
      acc_42 += t66
    end
    acc_42
  end
end

```

</details>

<details>
<summary><strong>Generated JavaScript (excerpt)</strong></summary>

```js
// Autogenerated by Kumi Codegen for schema KUMI_ab5095ff65347e715e158fac0f8baa864bf96c953ee33be671467d16a6202958
export class KumiCompiledModule {
  // ...
  
  _cart_total(input = this.input) {
    let acc_36 = 0.0;
    let t37 = input["items"];
    t37?.forEach((items_el_38, items_i_39) => {
      let t57 = items_el_38?.price;
      let t58 = items_el_38?.qty;
      let t59 = t57 * t58;
      acc_36 += t59;
    });
    return acc_36;
  }

  _cart_total_effective(input = this.input) {
    let acc_42 = 0.0;
    let t43 = input["items"];
    t43?.forEach((items_el_44, items_i_45) => {
      let t68 = items_el_44?.price;
      let t73 = items_el_44?.qty;
      let t70 = t68 > 100.0;
      let t74 = t68 * t73;
      let t64 = t74 * 0.9;
      let t66 = t70 ? t64 : t74;
      acc_42 += t66;
    });
    return acc_42;
  }
}
```

</details>

<details>
<summary><strong>How to emit</strong></summary>

This is not on the published version, but if you clone this repository you can just copy a ./golden/<schema_name> and modify schema.kumi as you and run bin/kumi golden test <schema_name> 

</details>
```
::contentReference[oaicite:0]{index=0}


---

## Install

```bash
gem install kumi
```

Requires Ruby 3.1+. No external dependencies.

---

## License

MIT License. See [LICENSE](LICENSE).
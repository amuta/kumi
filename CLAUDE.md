# CLAUDE.md

IMPORTANT!: Use `kumi parse` to see IR or Analysis States Diff - see docs/dev/parse-command.md
Remember, this gem is not on production yet, so no backward compatilibity is necessary. But do not change the public interfaces (e.g. DSL, Schema) without explicitly requested or demanded. 
We are using zeitwerk, i.e.: no requires
See all Available Functions in docs/FUNCTIONS.md

## Project Overview

Kumi is a Declarative logic and rules engine framework with static analysis for Ruby.

## Development Commands

### Testing
- `bundle exec rspec` - Run all tests
- `bundle exec rspec spec/path/to/specific_spec.rb` - Run specific test file
- `bundle exec rspec spec/path/to/specific_spec.rb:123` - Run specific test at line

## Architecture Overview

### Core Components

**Schema System** (`lib/kumi/schema.rb`):
- Entry point that ties together parsing, analysis, and compilation
- DSL method `schema(&block)` builds the syntax tree, runs analysis, and compiles to executable form
- Generates a `Runner` instance for executing queries against input data

**Parser** (`lib/kumi/ruby_parser{/*,.rb}`):

**Syntax Tree** (`lib/kumi/syntax/`):
- `node.rb` - Base node class with location tracking
- `root.rb` - Root schema node containing inputs, attributes, and traits
- `value_declaration.rb` - Value declaration nodes (formerly Attribute)
- `trait_declaration.rb` - Trait declaration nodes (formerly Trait)
- `input_declaration.rb` - Input field declaration nodes (formerly FieldDecl)
- `call_expression.rb` - Function call expression nodes
- `array_expression.rb` - Array expression nodes (formerly ListExpression)
- `hash_expression.rb` - Hash expression nodes (for future hash literals) (currently not used)
- `cascade_expression.rb` - Cascade expression nodes (conditional values)
- `case_expression.rb` - Case expression nodes (formerly WhenCaseExpression)
- `literal.rb` - Literal value nodes
- `input_reference.rb` - Input field reference nodes (formerly FieldRef) 
- `input_element_reference.rb` - Reference to nested input field (array -> obj.field) 
- `declaration_reference.rb` - Declaration reference value or trait nodes

**Analyzer** (`lib/kumi/analyzer.rb`):
- Multi-pass analysis system that validates schemas and builds dependency graphs
- **Pass 1**: `name_indexer.rb` - Find all names, check for duplicates
- **Pass 2**: `input_collector.rb` - Collect field metadata, validate conflicts
- **Pass 3**: `definition_validator.rb` - Validate basic structure
- **Pass 4**: `dependency_resolver.rb` - Build dependency graph
- **Pass 5**: `cycle_detector.rb` - Find circular dependencies
- **Pass 6**: `toposorter.rb` - Create evaluation order
- **Pass 7**: `type_inferencer.rb` - Infer types for all declarations
- **Pass 8**: `type_checker.rb` - Validate function types and compatibility using inferred types

**Compiler** (`lib/kumi/compiler.rb`):
- Compiles analyzed syntax tree into executable lambda functions
- Maps each expression type to a compilation method
- Handles function calls via `Kumi::Registry`
- Produces `CompiledSchema` with executable bindings

**Function Registry** (`lib/kumi/function_registry.rb`):
- Registry of available functions (operators, math, string, logical, collection operations)
- Supports custom function registration with type metadata
- Each function includes param_types, return_type, arity, and description
- Core functions include: `==`, `>`, `<`, `add`, `multiply`, `and`, `or`, `clamp`, etc.
- Function documents are generated by the script ./scripts/generate_function_docs.rb

### Key Patterns
**DSL Structure**:
```ruby
schema do
  input do
    # Recommended type-specific DSL methods
    string  :field_name
    integer :number_field, domain: 0..100
    array   :scores, elem: { type: :float }
    hash    :metadata, key: { type: :string }, val: { type: :any }

    array :line_items do
      float   :price
      integer :quantity
      string  :category
    end

    # Fields with no declared type
    any     :misc_field
  end

  trait :name, (expression)  # Boolean conditions
  value :name, expression    # Computed values
  value :name do             # Conditional logic
    on condition, result     # on <trait> ?,<trait> , <expr>
    base default_result      # base <expr>
  end
end
```

**IMPORTANT CASCADE CONDITION SYNTAX:**
In cascade expressions (`value :name do ... end`), trait references use bare identifiers:


**Expression Types**:
- `input.field_name` - Access input data with operator methods (>=, <=, >, <, ==, !=)
- `ref(:name)` - Reference other declarations
- `fn(:name, args...)` - Function calls
- `(expr1) & (expr2)` - Logical AND chaining
- `[element1, element2]` - Lists
- Literals (numbers, strings, booleans)

**Analysis Flow**:
1. Parse DSL â†’ Syntax Tree
2. Analyze Syntax Tree â†’ Analysis Result (dependency graph, type information, topo order)
3. Compile â†’ Executable Schema  
4. Execute with Runner

**Type System** (`lib/kumi/types.rb`):
- Symbol-based type system
- **Dual Type System**: Declared types (from input blocks) and inferred types (from expressions)
- Type inference for all declarations based on expression analysis
- Type primitives: `:string`, `:integer`, `:float`, `:boolean`, `:any`, `:symbol`, `:regexp`, `:time`, `:date`, `:datetime`
- Collection types: `array(:element_type)` and `hash(:key_type, :value_type)` helper functions

## Files for Understanding

. `docs/*` - Documents about Kumi, its features, DSL syntax, ... 
- `examples/*` Random examples of diverse contexts.

### Troubleshooting Schema Issues
DEBUG, DEBUG. DEBUG LOGS!


### Array Broadcasting System

**Vectorization**: Field access on array inputs (`input.items.price`) applies operations element-wise with map/reduce detection.

**Basic Broadcasting**:
```ruby
input do
  array :line_items do
    float   :price
    integer :quantity  
    string  :category
    array   :prices do
      element :integer, :val
    end
  end
end

# Element-wise computation - broadcasts over each item
value :subtotals, input.line_items.price * input.line_items.quantity
trait :is_taxable, (input.line_items.category != "digital")
```

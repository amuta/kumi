# CLAUDE.md

!! Remember, this gem is not on production yet, so no backward compatilibity is necessary. But do not change the public interfaces (e.g. DSL, Schema) without explicitly requested or demanded. 
!! We are using zeitwerk, i.e.: no requires


This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Kumi is a declarative decision-modeling compiler for Ruby that transforms complex business rules into executable dependency graphs. It features a multi-pass analyzer that validates rule interdependencies, detects cycles, infers types, and generates optimized evaluation functions. The system separates input field declarations from business logic through an explicit input block syntax.

## Development Commands

### Testing
- `bundle exec rspec` - Run all tests
- `bundle exec rspec spec/path/to/specific_spec.rb` - Run specific test file
- `bundle exec rspec spec/path/to/specific_spec.rb:123` - Run specific test at line

### Linting & Code Quality
- `bundle exec rubocop` - Run RuboCop linter
- `bundle exec rubocop -a` - Auto-fix RuboCop issues where possible
- `rake` - Run default task (includes rspec and rubocop)

### Gem Management
- `bundle install` - Install dependencies
- `gem build kumi.gemspec` - Build the gem
- `gem install ./kumi-*.gem` - Install locally built gem

## Architecture Overview

### Core Components

**Schema System** (`lib/kumi/schema.rb`):
- Entry point that ties together parsing, analysis, and compilation
- Provides the `schema(&block)` DSL method that builds the syntax tree, runs analysis, and compiles to executable form
- Generates a `Runner` instance for executing queries against input data

**Parser** (`lib/kumi/parser/`):
- `dsl.rb` - Main DSL parser that converts Ruby block syntax into AST nodes
- `dsl_builder_context.rb` - Context for building DSL elements with input/value/trait methods
- `dsl_cascade_builder.rb` - Specialized builder for cascade expressions
- `dsl_proxy.rb` - Proxy object for method delegation during parsing
- `input_dsl_proxy.rb` - Proxy for input block DSL supporting both `key` method and type-specific DSL methods
- `input_proxy.rb` - Proxy for `input.field_name` references in expressions

**Syntax Tree** (`lib/kumi/syntax/`):
- `node.rb` - Base node class with location tracking
- `root.rb` - Root schema node containing inputs, attributes, and traits
- `declarations.rb` - Attribute and trait declaration nodes  
- `expressions.rb` - Expression nodes (calls, lists, cascades)
- `terminal_expressions.rb` - Terminal nodes (literals, field references, bindings, field declarations)

**Analyzer** (`lib/kumi/analyzer.rb`):
- Multi-pass analysis system that validates schemas and builds dependency graphs
- **Pass 1**: `name_indexer.rb` - Find all names, check for duplicates
- **Pass 2**: `input_collector.rb` - Collect field metadata, validate conflicts
- **Pass 3**: `definition_validator.rb` - Validate basic structure
- **Pass 4**: `dependency_resolver.rb` - Build dependency graph
- **Pass 5**: `cycle_detector.rb` - Find circular dependencies
- **Pass 6**: `toposorter.rb` - Create evaluation order
- **Pass 7**: `type_inferencer.rb` - Infer types for all declarations
- **Pass 8**: `type_checker.rb` - Validate function types and compatibility using inferred types

**Compiler** (`lib/kumi/compiler.rb`):
- Transforms analyzed syntax tree into executable lambda functions
- Maps each expression type to a compilation method
- Handles function calls via `FunctionRegistry`
- Produces `CompiledSchema` with executable bindings

**Function Registry** (`lib/kumi/function_registry.rb`):
- Registry of available functions (operators, math, string, logical, collection operations)
- Supports custom function registration with comprehensive type metadata
- Each function includes param_types, return_type, arity, and description
- Core functions include: `==`, `>`, `<`, `add`, `multiply`, `and`, `or`, `clamp`, etc.
- Maintains backward compatibility with legacy type checking system
- Function documents are generated by the script ./scripts/generate_function_docs.rb

**Runner** (`lib/kumi/runner.rb`):
- Executes compiled schemas against input data
- Provides `fetch(key)` for individual value retrieval with caching
- Provides `slice(*keys)` for batch evaluation
- Provides `explain(key)` for detailed execution tracing

**Input Validation System** (`lib/kumi/input/` and `lib/kumi/domain/`):
- `input/validator.rb` - Main validation coordinator for type and domain checking
- `input/type_matcher.rb` - Type validation logic for primitive and complex types
- `input/violation_creator.rb` - Creates standardized violation objects with detailed messages
- `domain/validator.rb` - Domain constraint validation (ranges, arrays, procs)
- `domain/range_analyzer.rb` - Range domain analysis and validation
- `domain/enum_analyzer.rb` - Enumeration domain analysis and validation
- `domain/violation_formatter.rb` - Formats domain violation error messages

### Key Patterns

**DSL Structure**:
```ruby
schema do
  input do
    # Recommended type-specific DSL methods
    string  :field_name
    integer :number_field, domain: 0..100
    array   :scores, elem: { type: :float }
    hash    :metadata, key: { type: :string }, val: { type: :any }

    # Fields with no declared type
    any     :misc_field
  end

  trait :name, (expression)  # Boolean conditions with new syntax
  value :name, expression    # Computed values
  value :name do             # Conditional logic
    on condition, result
    base default_result
  end
end
```

**IMPORTANT CASCADE CONDITION SYNTAX:**
In cascade expressions (`value :name do ... end`), trait references use **symbols**, not bare identifiers:
```ruby
value :status do
  on :adult, "Adult Status"      # ✅ Correct - use :trait_name symbol
  on :verified, "Verified User"
  base "Unverified"
end

# NOT this:
value :status do
  on adult, "Adult Status"       # ❌ Wrong - don't use bare identifier in cascade
  on verified, "Verified User"   # ❌ Wrong
  base "Unverified"
end
```

**Input Block System**:
- **Required**: All schemas must have an `input` block declaring expected fields
- **Type Declarations**: Preferred via type-specific methods (e.g. `integer :field`, `string :name`, `any :field` for untyped fields)
- **Complex Types**: Use helper functions: `array(:element_type)` and `hash(:key_type, :value_type)`
- **Domain Constraints**: Fields can have domains: `integer :age, domain: 18..65` (validated at runtime)
- **Field Access**: Use `input.field_name` to reference input fields in expressions
- **Separation**: Input metadata (types, domains) is separate from business logic

**Expression Types**:
- `input.field_name` - Access input data with operator methods (>=, <=, >, <, ==, !=)
- `ref(:name)` - Reference other declarations
- `fn(:name, args...)` - Function calls
- `(expr1) & (expr2)` - Logical AND chaining
- `[element1, element2]` - Lists
- Literals (numbers, strings, booleans)

**Analysis Flow**:
1. Parse DSL → Syntax Tree
2. Analyze Syntax Tree → Analysis Result (dependency graph, type information, topo order)
3. Compile → Executable Schema  
4. Execute with Runner

**Type System** (`lib/kumi/types.rb`):
- Simple symbol-based type system for clean and intuitive declaration
- **Dual Type System**: Declared types (from input blocks) and inferred types (from expressions)
- Automatic type inference for all declarations based on expression analysis
- Type primitives: `:string`, `:integer`, `:float`, `:boolean`, `:any`, `:symbol`, `:regexp`, `:time`, `:date`, `:datetime`
- Collection types: `array(:element_type)` and `hash(:key_type, :value_type)` helper functions
- Type compatibility checking and unification algorithms for numeric types
- Enhanced error messages showing type provenance (declared vs inferred)
- Legacy compatibility constants maintained for backward compatibility

### Examples Directory

The `examples/` directory contains comprehensive examples showing Kumi usage patterns:
- `input_block_typing_showcase.rb` - Demonstrates input block typing features (current best practices)

*Note: Some examples may use deprecated syntax and should be updated to use the new input block system.*

## Test Structure

- `spec/kumi/` - Unit tests for core components
- `spec/integration/` - Integration tests for full workflows
- `spec/fixtures/` - Test fixtures and sample schemas
- `spec/support/` - Test helpers (`ast_factory.rb`, `schema_generator.rb`)

## Key Files for Understanding

1. `lib/kumi/schema.rb` - Start here to understand the main API
2. `examples/input_block_typing_showcase.rb` - Comprehensive example of current features
3. `lib/kumi/analyzer.rb` - Core analysis pipeline with multi-pass system
4. `lib/kumi/types.rb` - Static type system implementation
5. `lib/kumi/function_registry.rb` - Available functions and extension patterns
6. `lib/kumi/analyzer/passes/type_inferencer.rb` - Type inference algorithm
7. `lib/kumi/analyzer/passes/type_checker.rb` - Type validation with enhanced error messages
8. `spec/kumi/input_block_spec.rb` - Input block syntax and behavior
9. `spec/integration/compiler_integration_spec.rb` - End-to-end test examples
10. `documents/DSL.md` - Concise DSL syntax reference
11. `documents/AST.md` - AST node types and structure reference

## Input Block System Details

### Required Input Blocks
- **All schemas must have an input block** - This is now mandatory
- Input blocks declare expected fields with optional type and domain constraints
- **Empty input blocks are allowed** - Use `input {}` for schemas that don't require external data
- Fields are accessed via `input.field_name` syntax (replaces deprecated `key(:field)`)

### Type System Integration
- **Declared Types**: Explicit type declarations in input blocks (e.g. `integer :field`, `string :name`, `any :field`)
- **Inferred Types**: Types automatically inferred from expression analysis
- **Type Checking**: Validates compatibility between declared and inferred types
- **Enhanced Errors**: Error messages show type provenance (declared vs inferred)
- **Helper Functions**: Use `array(:type)` and `hash(:key_type, :value_type)` for complex types

### Parser Components
- `input_dsl_proxy.rb` - Supports type-specific DSL methods (`integer`, `float`, `string`, `boolean`, `array`, `hash`, `any`)
- `input_proxy.rb` - Handles `input.field_name` references in expressions
- `input_collector.rb` - Collects and validates field metadata consistency

### Domain Constraints
- Can be declared: `integer :age, domain: 18..65`
- **Implemented**: Domain validation is active and enforced at runtime
- Supports Range domains (`18..65`), Array domains (`%w[active inactive]`), and Proc domains for custom validation
- Field metadata includes domain information and runtime validation occurs during `Schema.from()`

### Type Examples
```ruby
input do
  # New type-specific DSL methods (recommended)
  string       :name
  integer      :age, domain: 18..65
  hash         :metadata, key: { type: :string }, val: { type: :any }

  # For untyped/any fields
  any          :misc
end
```

### Trait Syntax Evolution

**Current Syntax** (recommended):
```ruby
trait :adult, (input.age >= 18)
trait :qualified, (input.age >= 21) & (input.score > 80) & (input.verified == true)
```

**Composite Trait Syntax** (NEW - bare identifier references):
```ruby
# Base traits
trait :adult, (input.age >= 18)
trait :verified, (input.verified == true)
trait :high_score, (input.score > 80)

# Composite traits using bare identifier syntax
trait :eligible, adult & verified & high_score
trait :mixed, adult & (input.income > 50_000) & verified

# Backward compatibility - both syntaxes work together
trait :legacy_mix, adult & ref(:verified) & (input.score > 90)
```

**Deprecated Syntax** (with warnings):
```ruby
trait :adult, input.age, :>=, 18                    # OLD - shows deprecation warning
trait :qualified, input.age, :>=, 21, input.score  # OLD - shows deprecation warning
```

**Key Changes**:
- **NEW**: Bare identifier syntax allows direct trait reference: `adult` instead of `ref(:adult)`
- New syntax uses parenthesized expressions: `trait :name, (expression)`  
- FieldRef nodes have operator methods that create CallExpression nodes
- Logical AND chaining via `&` operator (Ruby limitation prevents `&&`)
- Only AND operations supported to maintain constraint satisfaction system
- **Backward Compatible**: Both `trait_name` and `ref(:trait_name)` work together
- Old syntax maintained with deprecation warnings for backward compatibility

## Common Development Tasks

### Adding New Analyzer Passes
1. Create pass class inheriting from `PassBase` in `lib/kumi/analyzer/passes/`
2. Implement `run(errors)` method that calls `set_state(key, value)` to store results
3. Add pass to `PASSES` array in `lib/kumi/analyzer.rb` in correct order
4. Consider dependencies on other passes (e.g., TypeChecker needs TypeInferencer)

### Working with AST Nodes
- All nodes include `Node` module for location tracking
- Use `spec/support/ast_factory.rb` helpers in tests
- Field declarations use `FieldDecl` nodes with name, domain, and type
- Field references use `FieldRef` nodes (from `input.field_name`) with operator methods
- FieldRef operator methods (>=, <=, >, <, ==, !=) create CallExpression nodes
- CallExpression `&` method enables logical AND chaining

### Testing Input Block Features
- See `spec/kumi/input_block_spec.rb` for comprehensive input block tests
- Use `schema_generator.rb` helper for creating test schemas
- All integration tests now require input blocks

## Architecture Design Principles

- **Multi-pass Analysis**: Each analysis pass has a single responsibility and builds on previous passes
- **Immutable Syntax Tree**: AST nodes are immutable; analysis results stored separately in analyzer state
- **Dependency-driven Evaluation**: All computation follows dependency graph to ensure correct order
- **Type Safety**: Optional but comprehensive type checking without breaking existing schemas
- **Backward Compatibility**: New features maintain compatibility with existing DSL and APIs
- **Ruby Integration**: Leverages Ruby's metaprogramming while providing structured analysis
- **Separation of Concerns**: Input metadata (types, domains) separated from business logic
- **Class Decomposition**: Large classes split into focused, single-responsibility components following RuboCop guidelines
- **Delegation Pattern**: Complex operations delegated to specialized analyzer and formatter classes
- **Unified Error Reporting**: Consistent, localized error messages throughout the system with clear interface patterns

## Code Organization Patterns

### Modular Validation Architecture
- **Coordinator Classes**: Main classes like `Input::Validator` and `Domain::Validator` coordinate but delegate complex logic
- **Specialized Analyzers**: Domain-specific classes like `RangeAnalyzer` and `EnumAnalyzer` handle specific constraint types
- **Formatter Classes**: Dedicated classes like `ViolationFormatter` handle message formatting with consistent patterns
- **Creator Classes**: Classes like `ViolationCreator` centralize object creation with standardized structure

### Testing Best Practices
- **Spec Organization**: Tests organized by component with clear separation between unit and integration tests
- **Error Variable Extraction**: RSpec patterns avoid multiline block chains by extracting error variables for assertion
- **Shared Contexts**: Use `schema_generator` and other shared contexts for consistent test setup

### RuboCop Compliance
- **Method Length**: Keep methods under 10 lines through extraction and delegation
- **Class Length**: Break classes over 100 lines into focused components
- **Complexity Metrics**: Reduce cyclomatic and ABC complexity through single-responsibility design
- **Style Consistency**: Follow Ruby style guidelines for readability and maintainability

### Error Reporting Architecture
- **Unified Interface**: Use `ErrorReporter` module and `ErrorReporting` mixin for consistent error handling
- **Location Information**: All errors must include proper file:line:column location data
- **Backward Compatibility**: Support both legacy `[location, message]` and new `ErrorEntry` formats
- **Type Categorization**: Errors categorized as `:syntax`, `:semantic`, `:type`, `:runtime`
- **Enhanced Messaging**: Support for error suggestions, context, and similar name detection

## Development Guides and Standards

### Error Reporting Standards
**For Parser Classes**:
```ruby
class MyParser
  include ErrorReporting
  
  def parse_something
    # Immediate error raising
    raise_syntax_error("Invalid syntax", location: current_location)
  end
end
```

**For Analyzer Passes**:
```ruby
class MyAnalyzerPass < PassBase
  def run(errors)
    # Error accumulation with enhanced location
    report_error(errors, "semantic error", location: node.loc, type: :semantic)
    
    # Backward compatible method
    add_error(errors, node.loc, "legacy format error")
  end
end
```

**Location Resolution Best Practices**:
- Always provide location information when available
- For complex errors (cycles, cross-references), find relevant AST nodes for location
- Use symbolic locations (`:cycle`, `:type_mismatch`) as fallback when no AST location available
- Prefer `node.loc` over `nil` for location parameter

### Testing Error Scenarios
- Use `spec/integration/dsl_breakage_spec.rb` patterns for comprehensive error testing
- Use `spec/integration/potential_breakage_spec.rb` for edge cases that should break but might not
- Verify error location precision with `spec/integration/error_location_spec.rb` patterns
- Test backward compatibility with existing analyzer pass specs

### Key Development Files
12. `lib/kumi/error_reporter.rb` - Central error reporting functionality
13. `lib/kumi/error_reporting.rb` - Mixin for consistent error interfaces  
14. `ERROR_REPORTING_INTERFACE.md` - Detailed error reporting implementation guide
15. `ON_ERRORS.md` - Comprehensive analysis of DSL breakage scenarios and error quality
16. `spec/integration/dsl_breakage_spec.rb` - Integration tests for all DSL breakage scenarios
17. `spec/integration/potential_breakage_spec.rb` - Edge cases that should break but might not
18. `docs/development/README.md` - Development guides directory index
19. `docs/development/error-reporting.md` - Comprehensive error reporting standards and patterns

# 
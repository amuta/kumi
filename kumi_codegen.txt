
### spec/codegen/ruby_v3/generator_spec.rb ###
# frozen_string_literal: true

require "spec_helper"

RSpec.describe Kumi::Codegen::RubyV3::Generator do
  let(:minimal_pack) do
    {
      "declarations" => [{ "name" => "test", "operations" => [], "result_op_id" => 0 }],
      "inputs" => [],
      "bindings" => { "ruby" => { "kernels" => [] } }
    }
  end
  
  describe "#initialize" do
    it "stores pack and module_name for render method" do
      generator = described_class.new(minimal_pack, module_name: "TestModule")
      
      expect(generator.instance_variable_get(:@pack)).to eq(minimal_pack)
      expect(generator.instance_variable_get(:@module_name)).to eq("TestModule")
    end
  end
  
  describe "#render" do
    context "pipeline orchestration order" do
      it "calls PackSanity validation before any other processing" do
        allow(Kumi::Codegen::RubyV3::Pipeline::PackSanity).to receive(:run).and_raise("Validation failed")
        
        generator = described_class.new(minimal_pack, module_name: "Test")
        
        expect { generator.render }.to raise_error("Validation failed")
      end
    end
    
    context "declarations processing order" do
      it "processes declarations in pack.declarations_in_order sequence" do
        pack_with_order = {
          "declarations" => [
            { 
              "name" => "first", "operations" => [], "result_op_id" => 0,
              "axes" => [], "axis_carriers" => [], "reduce_plans" => [], 
              "site_schedule" => {}, "inlining_decisions" => {}
            },
            { 
              "name" => "second", "operations" => [], "result_op_id" => 0,
              "axes" => [], "axis_carriers" => [], "reduce_plans" => [], 
              "site_schedule" => {}, "inlining_decisions" => {}
            }
          ],
          "inputs" => [],
          "bindings" => { "ruby" => { "kernels" => [] } }
        }
        
        # Mock pipeline modules to focus on orchestration order
        allow(Kumi::Codegen::RubyV3::Pipeline::PackSanity).to receive(:run)
        allow(Kumi::Codegen::RubyV3::Pipeline::ConstPlan).to receive(:run).and_return({ inline_ids: Set.new, prelude: [] })
        allow(Kumi::Codegen::RubyV3::Pipeline::DepPlan).to receive(:run).and_return({ inline_ids: Set.new, indexed: {} })
        allow(Kumi::Codegen::RubyV3::Pipeline::StreamLowerer).to receive(:run).and_return(double("CGIR::Function"))
        allow(Kumi::Codegen::RubyV3::RubyRenderer).to receive(:render).and_return("code")
        
        generator = described_class.new(pack_with_order, module_name: "Test")
        generator.render
        
        # If this doesn't crash, declarations were processed in correct order
        expect(Kumi::Codegen::RubyV3::RubyRenderer).to have_received(:render).with(
          hash_including(program: have_attributes(size: 2))
        )
      end
    end
  end
  
  describe "#pack_hash" do
    it "extracts hash values safely with empty fallback" do
      generator = described_class.new({}, module_name: "Test")
      
      result = generator.send(:pack_hash, {})
      
      expect(result).to eq("")
    end
    
    it "joins hash values with colon separator" do
      pack_with_hashes = { "hashes" => { "a" => "hash1", "b" => "hash2" } }
      generator = described_class.new({}, module_name: "Test")
      
      result = generator.send(:pack_hash, pack_with_hashes)
      
      expect(result).to eq("hash1:hash2")
    end
  end
end
### spec/codegen/ruby_v3/integration/actual_ruby_generation_spec.rb ###
# frozen_string_literal: true

require "spec_helper"

RSpec.describe "RubyV3 Integration: Actual Ruby Generation" do
  include PackTestHelper

  it "generates working Ruby code that can be evaluated" do
    schema = <<~KUMI
      schema do
        input do
          integer :x
          integer :y
        end
        
        value :sum, input.x + input.y
      end
    KUMI
    
    pack = pack_for(schema)
    generator = Kumi::Codegen::RubyV3::Generator.new(pack, module_name: "TestModule")
    
    result = generator.render
    
    # Should generate actual Ruby code, not just comments
    expect(result).to include("def _each_sum")
    expect(result).to include("def _eval_sum")
    expect(result).to include("def [](name)")
    expect(result).to include("def __call_kernel__")
    
    # Should contain actual code statements
    expect(result).to include("yield ")
    expect(result).to match(/v\d+ = /)  # Variable assignments
  end

  it "generates kernel dispatch code with actual implementations" do
    schema = <<~KUMI
      schema do
        input do
          integer :a
          integer :b
        end
        
        value :result, input.a + input.b
      end
    KUMI
    
    pack = pack_for(schema)
    generator = Kumi::Codegen::RubyV3::Generator.new(pack, module_name: "MathModule")
    
    result = generator.render
    
    # Should contain kernel implementations from pack
    expect(result).to include("def __call_kernel__")
    expect(result).to match(/return \(.*\)\.call\(\*args\)/)  # Kernel dispatch
  end
end
### spec/codegen/ruby_v3/integration/array_operations_spec.rb ###
# frozen_string_literal: true

require "spec_helper"

RSpec.describe "RubyV3 Integration: Array Operations" do
  include PackTestHelper

  it "generates code with proper loop structure for single-dimensional arrays" do
    schema = <<~KUMI
      schema do
        input do
          array :items do
            integer :price
          end
        end
        
        value :doubled_prices, input.items.price * 2
      end
    KUMI
    
    pack = pack_for(schema)
    generator = Kumi::Codegen::RubyV3::Generator.new(pack, module_name: "ArrayOps")
    
    generated_code = generator.render
    
    # Should contain proper loop structure
    expect(generated_code).to include('arr0 = @input["items"]')
    expect(generated_code).to include("i0 = 0")
    expect(generated_code).to include("while i0 < arr0.length")
    expect(generated_code).to include("a0 = arr0[i0]")
    expect(generated_code).to include("i0 += 1")
    
    # Should contain field access within loop
    expect(generated_code).to include('a0["price"]')
    
    # Should yield with proper indices
    expect(generated_code).to include("yield ")
    expect(generated_code).to include("[i0]")
    
    # Should use array materialization
    expect(generated_code).to include("__materialize_from_each(:doubled_prices)")
    
    # Test executable behavior
    eval(generated_code)
    processor = Object.new.extend(ArrayOps)
    input_data = { 
      "items" => [
        { "price" => 10 },
        { "price" => 20 },
        { "price" => 30 }
      ]
    }
    processor.instance_variable_set(:@input, input_data)
    
    expect(processor[:doubled_prices]).to eq([20, 40, 60])
  end
end
### spec/codegen/ruby_v3/integration/basic_generation_spec.rb ###
# frozen_string_literal: true

require "spec_helper"

RSpec.describe "RubyV3 Integration: Basic Generation" do
  include PackTestHelper

  it "generates Ruby module from simple schema without crashing" do
    schema = <<~KUMI
      schema do
        input do
          integer :x
        end
        
        value :double, input.x * 2
      end
    KUMI
    
    pack = pack_for(schema)
    generator = Kumi::Codegen::RubyV3::Generator.new(pack, module_name: "TestModule")
    
    result = generator.render
    
    expect(result).to be_a(String)
    expect(result).to include("module TestModule")
  end
end
### spec/codegen/ruby_v3/integration/cgir_operations_spec.rb ###
# frozen_string_literal: true

require "spec_helper"

RSpec.describe "RubyV3 Integration: CGIR Operations Processing" do
  include PackTestHelper

  it "processes CGIR operations without crashing and generates operation comments" do
    schema = <<~KUMI
      schema do
        input do
          integer :x
          integer :y
        end
        
        value :calculation, input.x + input.y * 2
      end
    KUMI
    
    pack = pack_for(schema)
    generator = Kumi::Codegen::RubyV3::Generator.new(pack, module_name: "TestModule")
    
    result = generator.render
    
    # Should contain CGIR operation comments (since renderer is stub)
    expect(result).to include("# TODO: Implement streaming method")
    expect(result).to include("# TODO: Implement materialization")
    
    # Should handle all operations without throwing unhandled case errors
    expect(result).not_to include("NoMethodError")
    expect(result).not_to include("unhandled")
  end
end
### spec/codegen/ruby_v3/integration/constructor_tuple_spec.rb ###
# frozen_string_literal: true

require "spec_helper"

RSpec.describe "RubyV3 Integration: Constructor Tuple Operations" do
  include PackTestHelper

  it "generates code that constructs arrays from multiple expressions" do
    schema = <<~KUMI
      schema do
        input do
          integer :x
          integer :y
        end
        
        value :triple, [input.x, input.x + input.y, input.y * 2]
      end
    KUMI
    
    pack = pack_for(schema)
    generator = Kumi::Codegen::RubyV3::Generator.new(pack, module_name: "TupleOps")
    
    generated_code = generator.render
    
    # Should contain array construction with multiple expressions
    expect(generated_code).to match(/v\d+ = \[v\d+, v\d+, v\d+\]/)
    
    # Should contain individual expression calculations
    expect(generated_code).to include('@input["x"]')
    expect(generated_code).to include('@input["y"]')
    
    # Should contain addition and multiplication operations
    expect(generated_code).to include("__call_kernel__")
    
    # Should yield the constructed tuple
    expect(generated_code).to match(/yield v\d+/)
    
    # Test executable behavior
    eval(generated_code)
    constructor = Object.new.extend(TupleOps)
    constructor.instance_variable_set(:@input, { "x" => 5, "y" => 3 })
    
    # Should return [5, 8, 6] = [x, x+y, y*2] = [5, 5+3, 3*2]
    expect(constructor[:triple]).to eq([5, 8, 6])
  end
end
### spec/codegen/ruby_v3/integration/corner_cases_spec.rb ###
# frozen_string_literal: true

require "spec_helper"

RSpec.describe "RubyV3 Integration: Corner Cases" do
  include PackTestHelper

  context "nested hash navigation (non-array structures)" do
    it "handles deep hash field access without array loops" do
      schema = <<~KUMI
        schema do
          input do
            hash :x do
              hash :y do
                integer :z
              end
            end
          end
        #{'  '}
          value :deep_value, input.x.y.z
        end
      KUMI

      pack = pack_for(schema)
      generator = Kumi::Codegen::RubyV3::Generator.new(pack, module_name: "NestedHash")

      result = generator.render

      # Should navigate hash fields without generating loops
      expect(result).to include('@input["x"]["y"]["z"]')
      expect(result).not_to include("while")
      expect(result).not_to include("arr0")
    end
  end

  context "empty arrays and edge cases" do
    it "handles empty array iteration gracefully" do
      schema = <<~KUMI
        schema do
          input do
            array :items do
              integer :value
            end
          end
        #{'  '}
          value :sum_values, fn(:sum, input.items.value)
        end
      KUMI

      pack = pack_for(schema)
      generator = Kumi::Codegen::RubyV3::Generator.new(pack, module_name: "EmptyArrays")

      generated_code = generator.render
      eval(generated_code)

      # Test with empty array
      calculator = Object.new
      calculator.extend(EmptyArrays)
      calculator.instance_variable_set(:@input, { "items" => [] })

      expect(calculator[:sum_values]).to eq(0) # Should return identity value
    end

    it "generates correct operation ordering for empty array reductions" do
      schema = <<~KUMI
        schema do
          input do
            array :numbers do
              integer :value
            end
          end
        #{'  '}
          value :total, fn(:sum, input.numbers.value)
        end
      KUMI

      pack = pack_for(schema)
      generator = Kumi::Codegen::RubyV3::Generator.new(pack, module_name: "OrderingTest")

      generated_code = generator.render

      # Should generate proper loop structure where operations are inside the loop
      expect(generated_code).to include("while i0 < arr0.length")
      expect(generated_code).to include("a0 = arr0[i0]")

      # Load and accumulate operations should be indented (inside loop)
      lines = generated_code.split("\n")
      while_line_idx = lines.find_index { |line| line.include?("while i0 < arr0.length") }
      end_line_idx = lines[(while_line_idx + 1)..-1].find_index { |line| line.strip == "end" }
      end_line_idx = (while_line_idx + 1) + end_line_idx if end_line_idx

      # Find operations between while and end
      loop_body_lines = lines[(while_line_idx + 1)...end_line_idx]
      value_access_line = loop_body_lines.find { |line| line.include?('a0["value"]') }
      acc_add_line = loop_body_lines.find { |line| line.include?("acc_") && line.include?("+=") }

      expect(value_access_line).not_to be_nil
      expect(acc_add_line).not_to be_nil

      # Both should be properly indented (inside the loop)
      expect(value_access_line).to start_with("      ")  # 6 spaces for depth 1
      expect(acc_add_line).to start_with("      ")       # 6 spaces for depth 1
    end
  end

  context "element arrays with different access patterns" do
    it "handles element array navigation correctly" do
      schema = <<~KUMI
        schema do
          input do
            array :cube do
              element :array, :layer do
                element :integer, :cell
              end
            end
          end
        #{'  '}
          value :cells, input.cube.layer.cell
        end
      KUMI

      pack = pack_for(schema)
      generator = Kumi::Codegen::RubyV3::Generator.new(pack, module_name: "ElementArrays")

      result = generator.render

      # Element arrays might need special handling
      expect(result).to be_a(String)
    end
  end

  context "missing identity values in reductions" do
    it "handles reducers without identity values gracefully" do
      # This tests the case where kernel binding has no "identity" field
      # Our KernelIndex should return nil, and StreamLowerer should handle it

      pack = {
        "declarations" => [
          {
            "name" => "test", "operations" => [
                                { "id" => 0, "op" => "Const", "args" => [1] },
                                { "id" => 1, "op" => "Reduce", "args" => [0], "attrs" => { "fn" => "custom.reduce" } }
                              ],
            "result_op_id" => 1, "axes" => [], "axis_carriers" => [],
            "reduce_plans" => [{ "op_id" => 1, "arg_id" => 0, "reducer_fn" => "custom.reduce" }],
            "site_schedule" => {
              "by_depth" => [{ "depth" => 0, "ops" => [
                { "id" => 0, "kind" => "const" }, { "id" => 1, "kind" => "reduce" }
              ] }],
              "hoisted_scalars" => []
            },
            "inlining_decisions" => {}
          }
        ],
        "inputs" => [],
        "bindings" => {
          "ruby" => {
            "kernels" => [
              { "kernel_id" => "custom.reduce", "impl" => "->(a,b) { [a,b].max }" }
              # NOTE: no "identity" field
            ]
          }
        }
      }

      generator = Kumi::Codegen::RubyV3::Generator.new(pack, module_name: "MissingIdentity")

      result = generator.render

      # Should handle nil identity gracefully (might use 0 as default)
      expect(result).to include("acc_")
      expect(result).to include("custom.reduce")
    end
  end

  context "circular or complex dependencies" do
    it "handles complex LoadDeclaration scenarios" do
      # This would test cases where declarations reference each other
      # or have complex inlining decisions
      expect(true).to be(true) # Placeholder
    end
  end

  context "very deep nesting levels" do
    it "handles 5+ levels of nesting without stack overflow" do
      schema = <<~KUMI
        schema do
          input do
            array :level1 do
              array :level2 do
                array :level3 do
                  array :level4 do
                    array :level5 do
                      integer :value
                    end
                  end
                end
              end
            end
          end
        #{'  '}
          value :deep_values, input.level1.level2.level3.level4.level5.value
        end
      KUMI

      pack = pack_for(schema)
      generator = Kumi::Codegen::RubyV3::Generator.new(pack, module_name: "DeepNesting")

      result = generator.render

      # Should handle deep nesting with proper variable naming
      expect(result).to include("arr4 = a3[\"level5\"]")
      expect(result).to include("a4[\"value\"]")
    end
  end

  context "unicode and special characters" do
    it "handles field names with special characters" do
      schema = <<~KUMI
        schema do
          input do
            integer :field_with_underscore
            integer :field123
          end
        #{'  '}
          value :result, input.field_with_underscore + input.field123
        end
      KUMI

      pack = pack_for(schema)
      generator = Kumi::Codegen::RubyV3::Generator.new(pack, module_name: "SpecialChars")

      result = generator.render

      # Should properly quote field names
      expect(result).to include('"field_with_underscore"')
      expect(result).to include('"field123"')
    end
  end
end

### spec/codegen/ruby_v3/integration/cross_declaration_dependencies_spec.rb ###
# frozen_string_literal: true

require "spec_helper"

RSpec.describe "RubyV3 Integration: Cross Declaration Dependencies" do
  include PackTestHelper

  it "handles dependencies between declarations correctly" do
    schema = <<~KUMI
      schema do
        input do
          integer :x
          integer :y
        end

        value :sum, input.x + input.y
        value :product, input.x * input.y
        value :difference, input.x - input.y
        value :results_array, [1, input.x + 10, input.y * 2, product]
      end
    KUMI

    pack = pack_for(schema)
    generator = Kumi::Codegen::RubyV3::Generator.new(pack, module_name: "CrossDeps")
    
    generated_code = generator.render
    
    # Should generate code that references other declarations
    expect(generated_code).to include("self[:product]")
    expect(generated_code).to include("def _each_product")
    expect(generated_code).to include("def _each_results_array")
    
    # Test that the generated code actually works
    eval(generated_code)
    
    calculator = CrossDeps.from({ "x" => 5, "y" => 3 })
    
    # Test individual values
    expect(calculator[:sum]).to eq(8)
    expect(calculator[:product]).to eq(15) 
    expect(calculator[:difference]).to eq(2)
    
    # Test cross-declaration dependency
    expected_results_array = [1, 15, 6, 15] # [1, x+10, y*2, product]
    expect(calculator[:results_array]).to eq(expected_results_array)
  end

  it "handles multiple levels of dependencies" do
    schema = <<~KUMI
      schema do
        input do
          integer :base
        end

        value :doubled, input.base * 2
        value :squared, doubled * doubled  
        value :final, squared + doubled + input.base
      end
    KUMI

    pack = pack_for(schema)
    generator = Kumi::Codegen::RubyV3::Generator.new(pack, module_name: "MultiDeps")
    
    generated_code = generator.render
    
    # Should reference intermediate declarations
    expect(generated_code).to include("self[:doubled]")
    
    eval(generated_code)
    
    calculator = MultiDeps.from({ "base" => 3 })
    
    expect(calculator[:doubled]).to eq(6)    # 3 * 2
    expect(calculator[:squared]).to eq(36)   # 6 * 6  
    expect(calculator[:final]).to eq(45)     # 36 + 6 + 3
  end

  it "handles dependencies in array contexts" do
    schema = <<~KUMI
      schema do
        input do
          array :items do
            integer :value
          end
        end

        value :doubled_values, input.items.value * 2
        value :items_with_doubled, input.items.value + doubled_values
      end
    KUMI

    pack = pack_for(schema)
    generator = Kumi::Codegen::RubyV3::Generator.new(pack, module_name: "ArrayDeps")
    
    generated_code = generator.render
    
    # Should reference array declaration with proper indexing
    expect(generated_code).to include("self[:doubled_values]")
    
    eval(generated_code)
    
    calculator = ArrayDeps.from({ "items" => [{"value" => 10}, {"value" => 20}] })
    
    expect(calculator[:doubled_values]).to eq([20, 40])
    expect(calculator[:items_with_doubled]).to eq([30, 60])  # [10+20, 20+40]
  end
end
### spec/codegen/ruby_v3/integration/dependency_inlining_spec.rb ###
# frozen_string_literal: true

require "spec_helper"

RSpec.describe "RubyV3 Integration: Dependency Inlining" do
  include PackTestHelper

  it "generates code with proper dependency resolution and inlining" do
    schema = <<~KUMI
      schema do
        input do
          array :employees do
            integer :salary
            integer :rating
          end
        end
        
        trait :high_earners, input.employees.salary >= 50000
        trait :high_ratings, input.employees.rating >= 4
        trait :bonus_eligible, high_earners & high_ratings
      end
    KUMI
    
    pack = pack_for(schema)
    generator = Kumi::Codegen::RubyV3::Generator.new(pack, module_name: "DependencyOps")
    
    generated_code = generator.render
    
    # Should contain loop structure for array processing
    expect(generated_code).to include('arr0 = @input["employees"]')
    expect(generated_code).to include("while i0 < arr0.length")
    
    # Should access both salary and rating fields
    expect(generated_code).to include('a0["salary"]')
    expect(generated_code).to include('a0["rating"]')
    
    # Should contain comparison operations
    expect(generated_code).to include("__call_kernel__")
    expect(generated_code).to include("core.gte")  # >=
    expect(generated_code).to include("core.and")  # &&
    
    # Should contain variable assignments for intermediate results
    expect(generated_code).to match(/v\d+ = /)
    
    # Should yield final computed values
    expect(generated_code).to match(/yield v\d+/)
    
    # Test executable behavior
    eval(generated_code)
    processor = Object.new.extend(DependencyOps)
    input_data = {
      "employees" => [
        { "salary" => 60000, "rating" => 5 },  # high earner + good rating
        { "salary" => 40000, "rating" => 5 },  # low earner + good rating  
        { "salary" => 70000, "rating" => 3 },  # high earner + poor rating
        { "salary" => 30000, "rating" => 2 }   # low earner + poor rating
      ]
    }
    processor.instance_variable_set(:@input, input_data)
    
    # high_earners: [true, false, true, false]
    expect(processor[:high_earners]).to eq([true, false, true, false])
    
    # bonus_eligible: [true, false, false, false] (high earner AND good rating)
    expect(processor[:bonus_eligible]).to eq([true, false, false, false])
  end
end
### spec/codegen/ruby_v3/integration/element_arrays_spec.rb ###
# frozen_string_literal: true

require "spec_helper"

RSpec.describe "RubyV3 Integration: Element Arrays" do
  include PackTestHelper

  it "handles nested element arrays with complex reductions" do
    schema = <<~KUMI
      schema do
        input do
          array :cube do
            element :array, :layer do
              element :array, :row do
                element :integer, :cell
              end
            end
          end
        end

        value :cube,  input.cube
        value :layer, input.cube.layer
        value :row, input.cube.layer.row
        value :cell, input.cube.layer.row.cell

        trait :cell_over_limit, input.cube.layer.row.cell > 100

        value :cell_sum, fn(:sum_if, input.cube.layer.row.cell, cell_over_limit)
        value :count_over_limit, fn(:sum, fn(:sum, fn(:sum_if, 1, cell_over_limit)))
      end
    KUMI

    pack = pack_for(schema)
    generator = Kumi::Codegen::RubyV3::Generator.new(pack, module_name: "ElementArrays")
    
    # Should be able to generate code without crashing
    generated_code = generator.render
    expect(generated_code).to be_a(String)
    expect(generated_code).to include("module ElementArrays")
    
    # Should handle nested array navigation
    expect(generated_code).to include("cube")
    expect(generated_code).to include("layer") 
    expect(generated_code).to include("row")
    expect(generated_code).to include("cell")
  end
end
### spec/codegen/ruby_v3/integration/executable_ruby_spec.rb ###
# frozen_string_literal: true

require "spec_helper"

RSpec.describe "RubyV3 Integration: Executable Ruby Code" do
  include PackTestHelper

  it "generates Ruby code that can be instantiated and executed" do
    schema = <<~KUMI
      schema do
        input do
          integer :x
          integer :y
        end
        
        value :sum, input.x + input.y
        value :product, input.x * input.y
      end
    KUMI
    
    pack = pack_for(schema)
    generator = Kumi::Codegen::RubyV3::Generator.new(pack, module_name: "Calculator")
    
    generated_code = generator.render
    
    # Eval the generated code to create the module
    eval(generated_code)
    
    # Create an object that extends the module with input data
    input_data = { "x" => 5, "y" => 3 }
    calculator = Object.new
    calculator.extend(Calculator)
    calculator.instance_variable_set(:@input, input_data)
    
    # Test the generated methods work
    expect(calculator[:sum]).to eq(8)     # 5 + 3
    expect(calculator[:product]).to eq(15) # 5 * 3
  end
end
### spec/codegen/ruby_v3/integration/field_navigation_spec.rb ###
# frozen_string_literal: true

require "spec_helper"

RSpec.describe "RubyV3 Integration: Complex Field Navigation" do
  include PackTestHelper

  it "handles deep field access through nested structures" do
    schema = <<~KUMI
      schema do
        input do
          array :depts do
            array :teams do
              integer :headcount
              string :name
            end
          end
        end
        
        value :team_sizes, input.depts.teams.headcount
        value :team_names, input.depts.teams.name
      end
    KUMI
    
    pack = pack_for(schema)
    generator = Kumi::Codegen::RubyV3::Generator.new(pack, module_name: "Navigation")
    
    result = generator.render
    
    # Should navigate through dept -> team hierarchy
    expect(result).to include("arr0 = @input[\"depts\"]")
    expect(result).to include("arr1 = a0[\"teams\"]")
    
    # Should access different fields from same level
    expect(result).to include("a1[\"headcount\"]")
    expect(result).to include("a1[\"name\"]")
  end
end
### spec/codegen/ruby_v3/integration/method_generation_spec.rb ###
# frozen_string_literal: true

require "spec_helper"

RSpec.describe "RubyV3 Integration: Method Generation" do
  include PackTestHelper

  it "generates _each_ and _eval_ methods for each declaration" do
    schema = <<~KUMI
      schema do
        input do
          integer :x
          integer :y
        end
        
        value :sum, input.x + input.y
        value :product, input.x * input.y
      end
    KUMI
    
    pack = pack_for(schema)
    generator = Kumi::Codegen::RubyV3::Generator.new(pack, module_name: "TestModule")
    
    result = generator.render
    
    expect(result).to include("def _each_sum")
    expect(result).to include("def _eval_sum")
    expect(result).to include("def _each_product")
    expect(result).to include("def _eval_product")
  end
end
### spec/codegen/ruby_v3/integration/mixed_inputs_spec.rb ###
# frozen_string_literal: true

require "spec_helper"

RSpec.describe "RubyV3 Integration: Mixed Scalar and Array Inputs" do
  include PackTestHelper

  it "handles schemas with both scalar and array inputs" do
    schema = <<~KUMI
      schema do
        input do
          array :items do
            float :price
          end
          float :tax_rate
        end
        
        value :taxed_price, input.items.price * (1.0 + input.tax_rate)
      end
    KUMI
    
    pack = pack_for(schema)
    generator = Kumi::Codegen::RubyV3::Generator.new(pack, module_name: "MixedInputs")
    
    result = generator.render
    
    # Should handle array field navigation
    expect(result).to include("a0[\"price\"]")
    
    # Should handle scalar field access 
    expect(result).to include("@input[\"tax_rate\"]")
    
    # Should contain arithmetic operations
    expect(result).to include("__call_kernel__")
  end
end
### spec/codegen/ruby_v3/integration/multi_dimensional_spec.rb ###
# frozen_string_literal: true

require "spec_helper"

RSpec.describe "RubyV3 Integration: Multi-dimensional Arrays" do
  include PackTestHelper

  it "handles nested array navigation with multiple depths" do
    schema = <<~KUMI
      schema do
        input do
          array :regions do
            array :offices do
              array :teams do
                integer :headcount
              end
            end
          end
        end
        
        value :headcount_data, input.regions.offices.teams.headcount
      end
    KUMI
    
    pack = pack_for(schema)
    generator = Kumi::Codegen::RubyV3::Generator.new(pack, module_name: "MultiDim")
    
    result = generator.render
    
    # Should generate nested loops for 3 levels
    expect(result).to include("arr0 = @input[\"regions\"]")
    expect(result).to include("arr1 = a0[\"offices\"]") 
    expect(result).to include("arr2 = a1[\"teams\"]")
    
    # Should handle deep field navigation
    expect(result).to include("a2[\"headcount\"]")
  end
end
### spec/codegen/ruby_v3/integration/nested_array_navigation_spec.rb ###
# frozen_string_literal: true

require "spec_helper"

RSpec.describe "RubyV3 Integration: Nested Array Navigation" do
  include PackTestHelper

  it "generates code with proper nested loop structure and chain navigation" do
    schema = <<~KUMI
      schema do
        input do
          array :departments do
            array :teams do
              integer :headcount
            end
          end
        end
        
        value :all_headcounts, input.departments.teams.headcount
      end
    KUMI
    
    pack = pack_for(schema)
    generator = Kumi::Codegen::RubyV3::Generator.new(pack, module_name: "NestedArrayOps")
    
    generated_code = generator.render
    
    # Should contain outer loop (depth 0)
    expect(generated_code).to include('arr0 = @input["departments"]')
    expect(generated_code).to include("i0 = 0")
    expect(generated_code).to include("while i0 < arr0.length")
    expect(generated_code).to include("a0 = arr0[i0]")
    
    # Should contain inner loop (depth 1)
    expect(generated_code).to include('arr1 = a0["teams"]')
    expect(generated_code).to include("i1 = 0") 
    expect(generated_code).to include("while i1 < arr1.length")
    expect(generated_code).to include("a1 = arr1[i1]")
    
    # Should access nested field correctly
    expect(generated_code).to include('a1["headcount"]')
    
    # Should yield with nested indices
    expect(generated_code).to include("yield ")
    expect(generated_code).to include("[i0, i1]")
    
    # Should close loops in reverse order
    expect(generated_code).to include("i1 += 1")
    expect(generated_code).to include("i0 += 1")
    
    # Test executable behavior
    eval(generated_code)
    processor = Object.new.extend(NestedArrayOps)
    input_data = {
      "departments" => [
        { "teams" => [{ "headcount" => 5 }, { "headcount" => 8 }] },
        { "teams" => [{ "headcount" => 3 }, { "headcount" => 12 }] }
      ]
    }
    processor.instance_variable_set(:@input, input_data)
    
    expected = [[5, 8], [3, 12]]  # Nested structure preserved
    expect(processor[:all_headcounts]).to eq(expected)
  end
end
### spec/codegen/ruby_v3/integration/pack_hash_spec.rb ###
# frozen_string_literal: true

require "spec_helper"

RSpec.describe "RubyV3 Integration: Pack Hash Embedding" do
  include PackTestHelper

  it "embeds pack hash in generated module comment" do
    schema = <<~KUMI
      schema do
        input do
          integer :value
        end
        
        value :result, input.value
      end
    KUMI
    
    pack = pack_for(schema)
    generator = Kumi::Codegen::RubyV3::Generator.new(pack, module_name: "TestModule")
    
    result = generator.render
    
    # Should contain pack hash from pack["hashes"] values
    expect(result).to match(/# Generated code with pack hash: \w+/)
  end
end
### spec/codegen/ruby_v3/integration/reduction_operations_spec.rb ###
# frozen_string_literal: true

require "spec_helper"

RSpec.describe "RubyV3 Integration: Reduction Operations" do
  include PackTestHelper

  it "generates code with proper accumulator initialization and reduction logic" do
    schema = <<~KUMI
      schema do
        input do
          array :numbers do
            integer :value
          end
        end
        
        value :total, fn(:sum, input.numbers.value)
      end
    KUMI
    
    pack = pack_for(schema)
    generator = Kumi::Codegen::RubyV3::Generator.new(pack, module_name: "ReductionOps")
    
    generated_code = generator.render
    
    # Should contain accumulator reset (identity value issue to be fixed separately)
    expect(generated_code).to match(/acc_\d+ = /)
    
    # Should contain accumulator addition
    expect(generated_code).to match(/acc_\d+ \+= v\d+/)
    
    # Should contain loop structure for reduction
    expect(generated_code).to include('arr0 = @input["numbers"]')
    expect(generated_code).to include("while i0 < arr0.length")
    
    # Should access field being reduced
    expect(generated_code).to include('a0["value"]')
    
    # Should yield the final accumulated result
    expect(generated_code).to match(/yield v\d+/)
    
    # Test executable behavior  
    eval(generated_code)
    reducer = Object.new.extend(ReductionOps)
    input_data = { 
      "numbers" => [
        { "value" => 10 },
        { "value" => 20 },
        { "value" => 30 }
      ]
    }
    reducer.instance_variable_set(:@input, input_data)
    
    expect(reducer[:total]).to eq(60)  # 10 + 20 + 30
  end
end
### spec/codegen/ruby_v3/integration/reductions_spec.rb ###
# frozen_string_literal: true

require "spec_helper"

RSpec.describe "RubyV3 Integration: Reductions and Aggregations" do
  include PackTestHelper

  it "handles sum reductions with accumulator logic" do
    schema = <<~KUMI
      schema do
        input do
          array :items do
            integer :quantity
          end
        end
        
        value :total_qty, fn(:sum, input.items.quantity)
      end
    KUMI
    
    pack = pack_for(schema)
    generator = Kumi::Codegen::RubyV3::Generator.new(pack, module_name: "Aggregator")
    
    result = generator.render
    
    # Should generate reduction logic with accumulators
    expect(result).to include("acc_")           # Accumulator variables
    expect(result).to include("agg.sum")        # Sum kernel dispatch
    expect(result).to include("_each_total_qty") # Streaming method
    expect(result).to include("_eval_total_qty") # Materialization method
    
    # Since it's a rank-0 result, should use direct return
    expect(result).to include("{ |value, _| return value }")
  end
end
### spec/codegen/ruby_v3/integration/scalar_operations_spec.rb ###
# frozen_string_literal: true

require "spec_helper"

RSpec.describe "RubyV3 Integration: Scalar Operations" do
  include PackTestHelper

  it "generates code for rank-0 scalar computations without loops" do
    schema = <<~KUMI
      schema do
        input do
          integer :x
          integer :y
        end
        
        value :sum, input.x + input.y
        value :difference, input.x - input.y
      end
    KUMI
    
    pack = pack_for(schema)
    generator = Kumi::Codegen::RubyV3::Generator.new(pack, module_name: "ScalarOps")
    
    generated_code = generator.render
    
    # Should NOT contain loop constructs for scalar operations
    expect(generated_code).not_to include("while")
    expect(generated_code).not_to include("arr0")
    expect(generated_code).not_to include("i0")
    
    # Should contain direct field access
    expect(generated_code).to include('@input["x"]')
    expect(generated_code).to include('@input["y"]')
    
    # Should use rank-0 materialization (direct return)
    expect(generated_code).to include("_each_sum { |value, _| return value }")
    expect(generated_code).to include("_each_difference { |value, _| return value }")
    
    # Test executable behavior
    eval(generated_code)
    calculator = Object.new.extend(ScalarOps)
    calculator.instance_variable_set(:@input, { "x" => 10, "y" => 3 })
    
    expect(calculator[:sum]).to eq(13)
    expect(calculator[:difference]).to eq(7)
  end
end
### spec/codegen/ruby_v3/pipeline/const_plan_spec.rb ###
# frozen_string_literal: true

require "spec_helper"

RSpec.describe Kumi::Codegen::RubyV3::Pipeline::ConstPlan do
  describe ".run" do
    context "pack-driven const placement (not heuristics)" do
      let(:ctx) do
        {
          ops: [
            {"id" => 0, "op" => "Const", "args" => [1]},
            {"id" => 2, "op" => "Const", "args" => [10]},
            {"id" => 5, "op" => "Const", "args" => [2]}
          ],
          site_schedule: {
            "hoisted_scalars" => [
              {"id" => 0, "kind" => "const"},
              {"id" => 2, "kind" => "const"}
            ]
          }
        }
      end
      
      it "puts hoisted consts in prelude" do
        result = described_class.run(ctx)
        
        expect(result[:prelude]).to contain_exactly(
          {name: "c0", value: 1},
          {name: "c2", value: 10}
        )
      end
      
      it "marks non-hoisted consts for inlining" do
        result = described_class.run(ctx)
        
        expect(result[:inline_ids]).to contain_exactly(5)
      end
      
      it "reads pack data, not usage count heuristics" do
        # This test ensures we follow hoisted_scalars, not usage patterns
        expect(described_class).not_to receive(:count_usages)
        
        described_class.run(ctx)
      end
    end
  end
end
### spec/codegen/ruby_v3/pipeline/decl_context_spec.rb ###
# frozen_string_literal: true

require "spec_helper"

RSpec.describe Kumi::Codegen::RubyV3::Pipeline::DeclContext do
  let(:mock_view) { double("PackView") }
  
  describe ".run" do
    context "PackView delegation for spec and plan data" do
      it "calls view.decl_spec and view.decl_plan with declaration name" do
        allow(mock_view).to receive(:decl_spec).with("target").and_return({ operations: [], result_op_id: 0 })
        allow(mock_view).to receive(:decl_plan).with("target").and_return({ 
          axes: [], axis_carriers: [], reduce_plans: [], site_schedule: {}, inlining_decisions: {} 
        })
        
        described_class.run(mock_view, "target")
        
        expect(mock_view).to have_received(:decl_spec).with("target").once
        expect(mock_view).to have_received(:decl_plan).with("target").once
      end
    end
    
    context "context key mapping from PackView responses" do
      it "maps spec.operations → ctx[:ops] and spec.result_op_id → ctx[:result_id]" do
        operations = [{ "id" => 5, "op" => "Const", "args" => [42] }]
        
        allow(mock_view).to receive(:decl_spec).and_return({ operations: operations, result_op_id: 5 })
        allow(mock_view).to receive(:decl_plan).and_return({ 
          axes: [], axis_carriers: [], reduce_plans: [], 
          site_schedule: {}, inlining_decisions: {} 
        })
        
        result = described_class.run(mock_view, "test")
        
        expect(result[:ops]).to eq(operations)
        expect(result[:result_id]).to eq(5)
      end
      
      it "maps plan.inlining_decisions → ctx[:inline] for DepPlan consumption" do
        inlining_decisions = { "op_1" => { "decision" => "inline" } }
        
        allow(mock_view).to receive(:decl_spec).and_return({ operations: [], result_op_id: 0 })
        allow(mock_view).to receive(:decl_plan).and_return({ 
          axes: [], axis_carriers: [], reduce_plans: [], 
          site_schedule: {}, inlining_decisions: inlining_decisions 
        })
        
        result = described_class.run(mock_view, "test")
        
        expect(result[:inline]).to eq(inlining_decisions)
      end
      
      it "preserves plan.axes and plan.axis_carriers for LoopPlanner consumption" do
        axes = ["regions", "offices"]
        axis_carriers = [{ "axis" => "regions", "via_path" => ["regions"] }]
        
        allow(mock_view).to receive(:decl_spec).and_return({ operations: [], result_op_id: 0 })
        allow(mock_view).to receive(:decl_plan).and_return({ 
          axes: axes, axis_carriers: axis_carriers, reduce_plans: [], 
          site_schedule: {}, inlining_decisions: {} 
        })
        
        result = described_class.run(mock_view, "test")
        
        expect(result[:axes]).to eq(axes)
        expect(result[:axis_carriers]).to eq(axis_carriers)
      end
      
      it "preserves plan.site_schedule for ConstPlan and StreamLowerer consumption" do
        site_schedule = { "by_depth" => [{ "depth" => 0, "ops" => [] }] }
        
        allow(mock_view).to receive(:decl_spec).and_return({ operations: [], result_op_id: 0 })
        allow(mock_view).to receive(:decl_plan).and_return({ 
          axes: [], axis_carriers: [], reduce_plans: [], 
          site_schedule: site_schedule, inlining_decisions: {} 
        })
        
        result = described_class.run(mock_view, "test")
        
        expect(result[:site_schedule]).to eq(site_schedule)
      end
      
      it "preserves plan.reduce_plans for StreamLowerer reduction handling" do
        reduce_plans = [{ "op_id" => 1, "arg_id" => 0, "reducer_fn" => "agg.sum" }]
        
        allow(mock_view).to receive(:decl_spec).and_return({ operations: [], result_op_id: 0 })
        allow(mock_view).to receive(:decl_plan).and_return({ 
          axes: [], axis_carriers: [], reduce_plans: reduce_plans, 
          site_schedule: {}, inlining_decisions: {} 
        })
        
        result = described_class.run(mock_view, "test")
        
        expect(result[:reduce_plans]).to eq(reduce_plans)
      end
    end
    
    context "unified context structure for pipeline modules" do
      it "includes declaration name in context for identification" do
        allow(mock_view).to receive(:decl_spec).and_return({ operations: [], result_op_id: 0 })
        allow(mock_view).to receive(:decl_plan).and_return({ 
          axes: [], axis_carriers: [], reduce_plans: [], site_schedule: {}, inlining_decisions: {} 
        })
        
        result = described_class.run(mock_view, "test_name")
        
        expect(result[:name]).to eq("test_name")
      end
      
      it "provides complete context hash with all required keys for pipeline" do
        allow(mock_view).to receive(:decl_spec).and_return({ operations: [], result_op_id: 0 })
        allow(mock_view).to receive(:decl_plan).and_return({ 
          axes: [], axis_carriers: [], reduce_plans: [], site_schedule: {}, inlining_decisions: {} 
        })
        
        result = described_class.run(mock_view, "test")
        
        # All pipeline modules expect these exact keys
        expect(result.keys).to contain_exactly(
          :name, :axes, :axis_carriers, :reduce_plans, :site_schedule, 
          :inline, :ops, :result_id
        )
      end
    end
  end
end
### spec/codegen/ruby_v3/pipeline/dep_plan_spec.rb ###
# frozen_string_literal: true

require "spec_helper"

RSpec.describe Kumi::Codegen::RubyV3::Pipeline::DepPlan do
  let(:mock_view) { double("PackView") }
  
  describe ".run" do
    context "pack-driven inlining decisions, not usage heuristics" do
      it "reads inlining_decisions from pack to classify LoadDeclaration ops" do
        allow(mock_view).to receive(:producer_axes).with("target_a").and_return(["axis1"])
        allow(mock_view).to receive(:producer_axes).with("target_b").and_return(["axis1", "axis2"])
        
        ctx = {
          ops: [
            { "id" => 1, "op" => "LoadDeclaration", "args" => ["target_a"] },
            { "id" => 2, "op" => "LoadDeclaration", "args" => ["target_b"] },
            { "id" => 3, "op" => "Map", "args" => [1, 2] }  # Not a LoadDeclaration
          ],
          inline: {
            "op_1" => { "decision" => "inline" },
            "op_2" => { "decision" => "indexed" }
          }
        }
        
        result = described_class.run(mock_view, ctx)
        
        # Pack says op_1 is inline
        expect(result[:inline_ids]).to contain_exactly(1)
        
        # Pack says op_2 is indexed, with producer rank
        expect(result[:indexed]).to eq({ 2 => { name: "target_b", rank: 2 } })
      end
      
      it "delegates producer rank calculation to view.producer_axes" do
        allow(mock_view).to receive(:producer_axes).with("multi_dim_target").and_return(["a", "b", "c"])
        
        ctx = {
          ops: [{ "id" => 5, "op" => "LoadDeclaration", "args" => ["multi_dim_target"] }],
          inline: { "op_5" => { "decision" => "indexed" } }
        }
        
        result = described_class.run(mock_view, ctx)
        
        expect(result[:indexed][5][:rank]).to eq(3)
        expect(mock_view).to have_received(:producer_axes).with("multi_dim_target")
      end
    end
    
    context "filters only LoadDeclaration operations" do
      it "ignores non-LoadDeclaration ops even if they have inlining decisions" do
        ctx = {
          ops: [
            { "id" => 1, "op" => "Map", "args" => [0, 1] },
            { "id" => 2, "op" => "Const", "args" => [42] },
            { "id" => 3, "op" => "LoadInput", "args" => [["x"]] }
          ],
          inline: {
            "op_1" => { "decision" => "inline" },
            "op_2" => { "decision" => "inline" }
          }
        }
        
        result = described_class.run(mock_view, ctx)
        
        expect(result[:inline_ids]).to be_empty
        expect(result[:indexed]).to be_empty
      end
    end
    
    context "missing inlining decisions default to indexed" do
      it "treats LoadDeclaration ops without inlining_decisions as indexed" do
        allow(mock_view).to receive(:producer_axes).with("no_decision_target").and_return(["axis"])
        
        ctx = {
          ops: [{ "id" => 7, "op" => "LoadDeclaration", "args" => ["no_decision_target"] }],
          inline: {}  # No decision for op_7
        }
        
        result = described_class.run(mock_view, ctx)
        
        expect(result[:inline_ids]).to be_empty
        expect(result[:indexed]).to eq({ 7 => { name: "no_decision_target", rank: 1 } })
      end
    end
    
    context "empty operations list" do
      it "returns empty sets when no LoadDeclaration ops exist" do
        ctx = {
          ops: [],
          inline: {}
        }
        
        result = described_class.run(mock_view, ctx)
        
        expect(result[:inline_ids]).to be_empty
        expect(result[:indexed]).to be_empty
      end
    end
  end
end
### spec/codegen/ruby_v3/pipeline/kernel_index_spec.rb ###
# frozen_string_literal: true

require "spec_helper"

RSpec.describe Kumi::Codegen::RubyV3::Pipeline::KernelIndex do
  describe ".run" do
    context "kernel implementation extraction with required fields" do
      it "extracts kernel_id → impl mappings using fetch (raises if missing)" do
        pack = {
          "bindings" => {
            "ruby" => {
              "kernels" => [
                { "kernel_id" => "core.add", "impl" => "->(a,b) { a + b }" },
                { "kernel_id" => "core.mul", "impl" => "->(a,b) { a * b }" }
              ]
            }
          }
        }

        result = described_class.run(pack)

        expect(result[:impls]).to eq({
                                       "core.add" => "->(a,b) { a + b }",
                                       "core.mul" => "->(a,b) { a * b }"
                                     })
      end

      it "raises KeyError when kernel_id or impl fields are missing" do
        pack_missing_impl = {
          "bindings" => {
            "ruby" => {
              "kernels" => [{ "kernel_id" => "core.add" }] # Missing "impl"
            }
          }
        }

        expect { described_class.run(pack_missing_impl) }.to raise_error(KeyError, /impl/)
      end
    end

    context "identity value extraction with optional fields" do
      it "extracts identity values using [] access (nil if missing, no error)" do
        pack = {
          "bindings" => {
            "ruby" => {
              "kernels" => [
                { "kernel_id" => "agg.sum", "impl" => "->(a,b) { a + b }", "attrs" => { "identity" => 0 } },
                { "kernel_id" => "agg.mul", "impl" => "->(a,b) { a * b }", "attrs" => { "identity" => 1 } },
                { "kernel_id" => "agg.max", "impl" => "->(a,b) { [a,b].max }" } # No identity
              ]
            }
          }
        }

        result = described_class.run(pack)

        expect(result[:identities]).to eq({
                                            "agg.sum" => 0,
                                            "agg.mul" => 1,
                                            "agg.max" => nil # Missing identity → nil, not error
                                          })
      end
    end

    context "target language parameter and safe extraction" do
      it "uses target parameter to select language bindings" do
        pack = {
          "bindings" => {
            "python" => {
              "kernels" => [{ "kernel_id" => "core.add", "impl" => "lambda a,b: a+b" }]
            },
            "ruby" => {
              "kernels" => [{ "kernel_id" => "core.add", "impl" => "->(a,b) { a + b }" }]
            }
          }
        }

        result = described_class.run(pack, target: "python")

        expect(result[:impls]["core.add"]).to eq("lambda a,b: a+b")
      end

      it "handles missing bindings gracefully with Array() wrapper" do
        pack_no_bindings = {}

        result = described_class.run(pack_no_bindings)

        expect(result[:impls]).to eq({})
        expect(result[:identities]).to eq({})
      end
    end

    context "structured result contract for downstream modules" do
      it "returns {impls:, identities:} structure that StreamLowerer expects" do
        pack = {
          "bindings" => {
            "ruby" => {
              "kernels" => [{ "kernel_id" => "test", "impl" => "test_impl", "attrs" => { "identity" => 42 } }]
            }
          }
        }

        result = described_class.run(pack)

        # StreamLowerer expects these exact keys
        expect(result).to have_key(:impls)
        expect(result).to have_key(:identities)
        expect(result[:impls]).to be_a(Hash)
        expect(result[:identities]).to be_a(Hash)
      end
    end
  end
end

### spec/codegen/ruby_v3/pipeline/loop_planner_spec.rb ###
# frozen_string_literal: true

require "spec_helper"

RSpec.describe Kumi::Codegen::RubyV3::Pipeline::LoopPlanner do
  describe ".run" do
    context "rank calculation from axes" do
      it "returns axes.length as rank" do
        ctx = {
          axes: ["regions", "offices", "teams", "employees"],
          axis_carriers: []
        }
        
        result = described_class.run(ctx)
        
        expect(result[:rank]).to eq(4)
      end
      
      it "handles scalar (rank 0) declarations" do
        ctx = {
          axes: [],
          axis_carriers: []
        }
        
        result = described_class.run(ctx)
        
        expect(result[:rank]).to eq(0)
      end
    end
    
    context "depth indexing assigns sequential depths starting from 0" do
      it "maps axis_carriers to depth-indexed loops with preserved via_path" do
        ctx = {
          axes: ["regions", "offices", "teams"],
          axis_carriers: [
            { "axis" => "regions", "via_path" => ["regions"] },
            { "axis" => "offices", "via_path" => ["regions", "offices"] },
            { "axis" => "teams", "via_path" => ["regions", "offices", "teams"] }
          ]
        }
        
        result = described_class.run(ctx)
        
        expect(result[:loops]).to eq([
          { depth: 0, via_path: ["regions"] },
          { depth: 1, via_path: ["regions", "offices"] },
          { depth: 2, via_path: ["regions", "offices", "teams"] }
        ])
      end
    end
    
    context "via_path cumulative navigation pattern" do
      it "preserves exact via_path arrays for loop navigation" do
        # This tests the critical pattern: via_path is cumulative
        # depth 0: navigate to ["regions"]
        # depth 1: navigate to ["regions", "offices"] 
        # depth 2: navigate to ["regions", "offices", "teams"]
        ctx = {
          axes: ["batches", "items"],
          axis_carriers: [
            { "axis" => "batches", "via_path" => ["data", "batches"] },
            { "axis" => "items", "via_path" => ["data", "batches", "items"] }
          ]
        }
        
        result = described_class.run(ctx)
        
        loops = result[:loops]
        expect(loops[0][:via_path]).to eq(["data", "batches"])
        expect(loops[1][:via_path]).to eq(["data", "batches", "items"])
        
        # StreamLowerer will use these exact paths for navigation
        # depth 0: @input["data"]["batches"]
        # depth 1: a0["items"]
      end
    end
    
    context "empty axis_carriers for scalar computations" do
      it "returns empty loops array for rank-0 declarations" do
        ctx = {
          axes: [],
          axis_carriers: []
        }
        
        result = described_class.run(ctx)
        
        expect(result[:loops]).to eq([])
        expect(result[:rank]).to eq(0)
      end
    end
  end
end
### spec/codegen/ruby_v3/pipeline/pack_sanity_spec.rb ###
# frozen_string_literal: true

require "spec_helper"

RSpec.describe Kumi::Codegen::RubyV3::Pipeline::PackSanity do
  describe ".run" do
    context "pack structure validation with clear error messages" do
      it "requires pack['declarations'] to be an Array" do
        pack_no_declarations = {}
        
        expect { described_class.run(pack_no_declarations) }.to raise_error(KeyError, "declarations missing")
      end
      
      it "requires pack['inputs'] to be an Array" do
        pack_no_inputs = { "declarations" => [] }
        
        expect { described_class.run(pack_no_inputs) }.to raise_error(KeyError, "inputs missing")
      end
      
      it "rejects non-Array declarations field" do
        pack_hash_declarations = { "declarations" => {}, "inputs" => [] }
        
        expect { described_class.run(pack_hash_declarations) }.to raise_error(KeyError, "declarations missing")
      end
      
      it "rejects non-Array inputs field" do
        pack_hash_inputs = { "declarations" => [], "inputs" => {} }
        
        expect { described_class.run(pack_hash_inputs) }.to raise_error(KeyError, "inputs missing")
      end
    end
    
    context "successful validation returns true" do
      it "returns true when pack has required Array fields" do
        valid_pack = { "declarations" => [], "inputs" => [] }
        
        result = described_class.run(valid_pack)
        
        expect(result).to be(true)
      end
    end
  end
end
### spec/codegen/ruby_v3/pipeline/pack_view_spec.rb ###
# frozen_string_literal: true

require "spec_helper"

RSpec.describe Kumi::Codegen::RubyV3::Pipeline::PackView do
  let(:simple_math_pack) do
    JSON.parse(File.read("golden/simple_math/expected/pack.json"))
  end
  
  let(:pack_view) { described_class.new(simple_math_pack) }
  
  describe "#declarations_in_order" do
    it "returns declaration names in pack order" do
      expect(pack_view.declarations_in_order).to eq(["difference", "product", "results_array", "sum"])
    end
  end
  
  describe "#decl_spec" do
    it "extracts operations and result_op_id" do
      spec = pack_view.decl_spec("sum")
      
      expect(spec[:operations]).to be_an(Array)
      expect(spec[:operations].size).to eq(3)
      expect(spec[:result_op_id]).to eq(2)
    end
  end
  
  describe "#decl_plan" do
    it "extracts execution plan data" do
      plan = pack_view.decl_plan("sum")
      
      expect(plan[:axes]).to eq([])
      expect(plan[:axis_carriers]).to eq([])
      expect(plan[:site_schedule]).to be_a(Hash)
      expect(plan[:site_schedule]["by_depth"]).to be_an(Array)
    end
  end
  
  describe "#input_chain_by_path" do
    it "finds chain for simple field path" do
      chain = pack_view.input_chain_by_path(["x"])
      
      expect(chain).to be_an(Array)
      expect(chain.size).to eq(1)
      expect(chain[0]["kind"]).to eq("field_leaf")
      expect(chain[0]["key"]).to eq("x")
    end
    
    it "raises clear KeyError when path not found" do
      expect { pack_view.input_chain_by_path(["nonexistent"]) }
        .to raise_error(KeyError, 'Chain not found for path: ["nonexistent"]')
    end
  end
end
### spec/codegen/ruby_v3/pipeline/stream_lowerer_spec.rb ###
# frozen_string_literal: true

require "spec_helper"

RSpec.describe Kumi::Codegen::RubyV3::Pipeline::StreamLowerer do
  describe ".emit_chain_access" do
    context "Issue #2 fix: chain navigation counts array_fields, not declaration rank" do
      it "uses @input when no array_field steps in chain" do
        chain = [{ "kind" => "field_leaf", "key" => "price" }]
        
        result = described_class.emit_chain_access(chain, 0, 2)
        
        expect(result).to eq('@input["price"]')
      end
      
      it "uses a0 when 1 array_field step in chain" do
        chain = [
          { "kind" => "array_field", "key" => "items" },
          { "kind" => "field_leaf", "key" => "price" }
        ]
        
        result = described_class.emit_chain_access(chain, 1, 2)
        
        expect(result).to eq('a0["price"]')
      end
      
      it "uses a1 when 2 array_field steps in chain" do
        chain = [
          { "kind" => "array_field", "key" => "batches" },
          { "kind" => "array_field", "key" => "items" },
          { "kind" => "field_leaf", "key" => "price" }
        ]
        
        result = described_class.emit_chain_access(chain, 2, 3)
        
        expect(result).to eq('a1["price"]')
      end
      
      it "builds nested field access correctly" do
        chain = [
          { "kind" => "field_leaf", "key" => "user" },
          { "kind" => "field_leaf", "key" => "profile" },
          { "kind" => "field_leaf", "key" => "name" }
        ]
        
        result = described_class.emit_chain_access(chain, 0, 1)
        
        expect(result).to eq('@input["user"]["profile"]["name"]')
      end
    end
  end
  
  describe ".run with reductions" do
    let(:mock_view) { double("PackView") }
    let(:loop_shape) { { rank: 1, loops: [] } }
    let(:consts) { { inline_ids: Set.new, prelude: [] } }
    let(:deps) { { inline_ids: Set.new, indexed: {} } }
    
    context "reduction identity values and two-phase wiring" do
      it "creates AccReset with identity at reduce depth, AccAdd at value depth" do
        identities = { "agg.sum" => 0, "agg.mul" => 1 }
        ctx = {
          name: "test",
          result_id: 2,
          ops: [
            { "id" => 1, "op" => "LoadInput", "args" => [["values"]] },
            { "id" => 2, "op" => "Reduce", "args" => [1], "attrs" => { "fn" => "agg.sum" } }
          ],
          reduce_plans: [
            { "op_id" => 2, "arg_id" => 1, "reducer_fn" => "agg.sum" }
          ],
          site_schedule: {
            "by_depth" => [
              { "depth" => 1, "ops" => [{ "id" => 1, "kind" => "loadinput" }] },
              { "depth" => 0, "ops" => [{ "id" => 2, "kind" => "reduce" }] }
            ]
          }
        }
        
        allow(mock_view).to receive(:input_chain_by_path).and_return([{ "kind" => "field_leaf", "key" => "values" }])
        
        result = described_class.run(mock_view, ctx, loop_shape:, consts:, deps:, identities:)
        
        # AccReset at reduce depth (0) with correct identity
        acc_reset = result.ops.find { |op| op[:k] == :AccReset }
        expect(acc_reset[:depth]).to eq(0)
        expect(acc_reset[:init]).to eq(0)
        expect(acc_reset[:name]).to eq("acc_2")
        
        # AccAdd at value depth (1)
        acc_add = result.ops.find { |op| op[:k] == :AccAdd }
        expect(acc_add[:depth]).to eq(1)
        expect(acc_add[:expr]).to eq("v1")
        expect(acc_add[:name]).to eq("acc_2")
      end
    end
    
    context "result yield depth is pack-driven, not guessed" do
      it "yields at result operation's scheduled depth, not [rank-1, 0].max" do
        ctx = {
          name: "test",
          result_id: 5,
          reduce_plans: [],
          ops: [{ "id" => 5, "op" => "Map", "args" => [1, 2], "attrs" => { "fn" => "core.add" } }],
          site_schedule: {
            "by_depth" => [
              { "depth" => 3, "ops" => [{ "id" => 5, "kind" => "map" }] }
            ]
          }
        }
        
        result = described_class.run(mock_view, ctx, loop_shape:, consts:, deps:, identities: {})
        
        yield_op = result.ops.find { |op| op[:k] == :Yield }
        expect(yield_op[:depth]).to eq(3)  # Pack says depth 3, not rank-1=0
      end
    end
  end
  
  describe ".run with operation ordering" do
    let(:mock_view) { double("PackView") }
    let(:consts) { { inline_ids: Set.new, prelude: [] } }
    let(:deps) { { inline_ids: Set.new, indexed: {} } }
    
    context "operations are sorted by logical stages" do
      it "places CloseLoop after all deeper depth operations" do
        loop_shape = { rank: 0, loops: [{ depth: 0, via_path: ["items"] }] }
        allow(mock_view).to receive(:input_chain_by_path).and_return([
          { "kind" => "array_field", "key" => "items" }, 
          { "kind" => "field_leaf", "key" => "value" }
        ])
        
        ctx = {
          name: "sum_values",
          result_id: 1,
          ops: [
            { "id" => 0, "op" => "LoadInput", "args" => [["items"]] },
            { "id" => 1, "op" => "Reduce", "args" => [0], "attrs" => { "fn" => "agg.sum" } }
          ],
          reduce_plans: [
            { "op_id" => 1, "arg_id" => 0, "reducer_fn" => "agg.sum" }
          ],
          site_schedule: {
            "by_depth" => [
              { "depth" => 1, "ops" => [{ "id" => 0, "kind" => "loadinput" }] },
              { "depth" => 0, "ops" => [{ "id" => 1, "kind" => "reduce" }] }
            ]
          }
        }
        identities = { "agg.sum" => 0 }
        
        result = described_class.run(mock_view, ctx, loop_shape:, consts:, deps:, identities:)
        
        # Find operation indices
        acc_reset_idx = result.ops.find_index { |op| op[:k] == :AccReset }
        open_loop_idx = result.ops.find_index { |op| op[:k] == :OpenLoop }
        load_input_idx = result.ops.find_index { |op| op[:k] == :Emit && op[:code].include?("a0") }
        acc_add_idx = result.ops.find_index { |op| op[:k] == :AccAdd }
        close_loop_idx = result.ops.find_index { |op| op[:k] == :CloseLoop }
        result_idx = result.ops.find_index { |op| op[:k] == :Emit && op[:code].match?(/^v\d+ = acc_\d+$/) }
        yield_idx = result.ops.find_index { |op| op[:k] == :Yield }
        
        # Verify correct ordering
        expect(acc_reset_idx).to be < open_loop_idx
        expect(open_loop_idx).to be < load_input_idx
        expect(load_input_idx).to be < acc_add_idx
        expect(acc_add_idx).to be < close_loop_idx
        expect(close_loop_idx).to be < result_idx
        expect(result_idx).to be < yield_idx
      end
    end
  end
  
  describe ".run with LoadInput" do
    let(:mock_view) { double("PackView") }
    let(:loop_shape) { { rank: 0, loops: [] } }
    let(:consts) { { inline_ids: Set.new, prelude: [] } }
    let(:deps) { { inline_ids: Set.new, indexed: {} } }
    
    context "LoadInput delegates to chain resolution" do
      it "calls view.input_chain_by_path and emit_chain_access for field navigation" do
        chain = [{ "kind" => "field_leaf", "key" => "x" }]
        allow(mock_view).to receive(:input_chain_by_path).with(["x"]).and_return(chain)
        
        ctx = {
          name: "test", 
          result_id: 0,
          reduce_plans: [],
          ops: [{ "id" => 0, "op" => "LoadInput", "args" => [["x"]] }],
          site_schedule: {
            "by_depth" => [{ "depth" => 0, "ops" => [{ "id" => 0, "kind" => "loadinput" }] }]
          }
        }
        
        result = described_class.run(mock_view, ctx, loop_shape:, consts:, deps:, identities: {})
        
        load_op = result.ops.find { |op| op[:k] == :Emit && op[:code].include?("v0") }
        expect(load_op[:code]).to eq('v0 = @input["x"]')
        expect(mock_view).to have_received(:input_chain_by_path).with(["x"])
      end
    end
  end
end